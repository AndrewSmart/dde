
var MakeInstruction = class MakeInstruction{
   //utilities

    //this is a lousy test. It presumes the src is valid JS and that
    //it is generated by MakeInstruction, so it just filters out
    //the few items you can make with MakeInstruction that
    //aren't valid on a do_list
    static src_looks_like_valid_instruction(src){
       if(starts_with_one_of(src, ["new Dexter(", "new Serial("])){
           return false
       }
       else { return true }
    }

    static dialog_contains_move_all_joints_with_joints(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(MiIns.instruction_name_in_family_class(instruction_name, MiIns.move_all_joints_family)){
            let id = this.arg_name_to_dom_elt_id("joint1")
            let elt = window[id]
            if(elt) { return true }
            else    { return false }
        }
        else { return false }
    }
    static dialog_contains_move_to_with_separate_xyzs(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(MiIns.instruction_name_in_family_class(instruction_name, MiIns.move_to_family)){
            let id = this.arg_name_to_dom_elt_id("x")
            let elt = window[id]
            if(elt) { return true }
            else    { return false }
        }
        else { return false }
    }

    static call_obj_arg_obj_with_name(call_obj, arg_name){
        for(let arg_obj of call_obj.args){
            if(arg_obj.name == arg_name) { return arg_obj }
        }
        dde_error("call_obj_arg_obj_with_name couldn't find: " + arg_name + " in: " + call_obj)
    }


    //you can pass "instruction_name" even though its not really an "arg"
    static arg_name_to_dom_elt_id(arg_name){
        if(arg_name.startsWith("mi_arg_")) { return arg_name }
        //if(arg_name.startsWith("...")){ arg_name = arg_name.substring(3) }
        return "mi_arg_" + arg_name + "_id"
    }

    static dom_elt_id_to_arg_name(dom_elt_id){
        let end_pos = dom_elt_id.length - 3
        return dom_elt_id.substring(7, end_pos)
    }

    //the default color is transparent
    static set_border_color_of_arg(arg_name, color="rgb(238, 238, 238)"){
        let id = this.arg_name_to_dom_elt_id(arg_name)
        let elt = window[id]
        if(elt){
          elt.style.borderColor = color
        }
    }

    static clean_instruction_name(instruction_name){
        if(instruction_name.startsWith("new ")){
            instruction_name = instruction_name.substring(4).trim()
        }
        return instruction_name
    }
    //end utilities

    static find_arg_val_src_in_arg_name_val_src_pairs(arg_name, arg_name_src_pairs){
        for(let pair of arg_name_src_pairs) { if(arg_name == pair[0]) { return pair[1] } }
        return undefined
    }


    //top level fn, called when user option-clicks in editor, passed the selected src.
    //first arg can be a string of js src, or a call obj (used by MakeInstruction.run
    static show(instruction_call_src=null, selected_robot_full_name="", show_doc=true){
        misc_pane_menu_id.value = "Make Instruction"
        let call_obj
        if(typeof(instruction_call_src) == "string"){ //don't use pipeline because we don't want to merge in prev_vals when coming from the editor, just instrudtion def defaults overlayed with src values
            call_obj = MiIns.make_from_instruction_source_no_args(instruction_call_src). //just fill in instruction name
                       merge_in_from_instruction_def().
                       merge_in_src(instruction_call_src)  //do not merge in special_defaults nor prev_values
        }
        else if (instruction_call_src == null){
            call_obj = MiIns.make_from_instruction_name_no_args("Dexter.move_all_joints")
            for(let i = 1; i < 8; i++) {  //not quite the same as merge_in_special_defaults
                let arg_name = "joint" + i
                call_obj.args_obj[arg_name] = "0"
            }
        }
        else {call_obj = instruction_call_src }

        sim_pane_content_id.innerHTML =
            "<div style='background-color:#EEEEEE;margin-bottom:10px;'>" +
                "<div style='font-size:14px;font-weight:700;margin-left:50px;'>Make Instruction</div>" +
                this.make_job_robots_select_html(selected_robot_full_name) +
                "<div style='white-space:nowrap;'>" +  //white-space:nowrap;
                    this.make_instruction_menu_html() +
                    this.make_instruction_name_html() +
                "</div>" +
                "<div id='mi_args_id'></div>" +
                this.replace_args_wrapper_html(call_obj) + "<br/>" +
                "<input id='mi_insert_default_args_id' type='checkbox'> Insert default args</input><br/>" +
                this.bottom_buttons_html() +
                MiRecord.make_html() +
            "</div>"
        $("#mi_instruction_menu_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' })
        $("#mi_instruction_menu_id").jqxMenu('setItemOpenDirection', 'mi_instruction_id', 'right', 'up');
        $("#mi_instruction_instance_name_id").jqxComboBox({width: '90px', height: '20px'})
        MiRecord.set_initial_states()
        this.update_instruction_name_and_args(call_obj, show_doc)
    }

    static is_shown(){
        if(window["mi_instruction_menu_id"]) { return true }
        else { return false }
    }

    static make_job_robots_select_html(selected_robot_full_name=""){
        var result = "<div style='margin-top:5px;'>Job default robot: " +
                     "<select id='mi_job_wrapper_robot_name_id' style='font-size:14px;width:130px;'" +
                     " title='Supplies the robot for instructions prefixed\n" +
                             "with a robot class (like Dexter or Serial)\n" +
                             "but no robot instance.')>"
        for(let robot_class_name of ["Brain", "Dexter", "Human", "Serial"]){
            for(let name of window[robot_class_name].all_names){
                let full_name = robot_class_name + "." + name
                let sel_attr = ((full_name == selected_robot_full_name) ? " selected='selected' " : "")
                result += "<option " + sel_attr + ">" + full_name + "</option>"
            }
        }
        result += "</select></div>"
        return result
    }

    static make_instruction_menu_item_html(label_array){
      let result = "<li>" + label_array[0] + "<ul>"
      for(let i = 1; i < label_array.length; i++){
         let label = label_array[i]  //setting the width below fails. usingn title lets you see long menu items
         let title
         if (label == "function*") { title = "generator"}
         else if (["new Dexter", "new Serial"].includes(label)) { title = "A Robot instance is not a valid do_list item." }
         else { title = label}
         result += "<li style='width:300px;' title='" + title + "' onclick='MakeInstruction.instruction_menu_click(event)'>" + label + "</li>"
      }
      result += "</ul></li>"
      return result
    }
    static make_instruction_menu_html(){
       let result = `<div title='Choose the class of instruction to make.' id='mi_instruction_menu_id' class='dde_menu' style="display:inline-block;height:15px;padding:0px;margin-top:5px;">
                      <ul style="display:inline-block;padding:0;margin-top:0px;">
                        <li id="mi_instruction_id" style="display:inline-block;padding-left:3px;padding-right:0px;">Instruction&#9660;<ul>`
       for(let labels of this.menu_hierarchy){
           result += this.make_instruction_menu_item_html(labels)
       }
       result += "</ul></li></ul></div>"
       return result
    }
    static instruction_menu_item_parent(label){
       for(let submenu_array of MakeInstruction.menu_hierarchy){
           if(submenu_array.includes(label)) { return submenu_array[0] }
       }
    }
    static instruction_menu_item_prefix(label){
        let parent_label = this.instruction_menu_item_parent(label)
        if      (parent_label.startsWith("Dexter")) { return "Dexter."}
        else if (parent_label.startsWith("Human"))  { return "Human."}
        else if (parent_label.startsWith("Robot"))  { return "Robot."}
        else if (parent_label.startsWith("Serial")) { return "Serial."}
        else { return "" }
    }

    static instruction_menu_click(event){
        let instruction_class_name = event.target.innerText // ie "move_all_joints"
        let instruction_superclass_name = this.instruction_menu_item_prefix(instruction_class_name) //ie "Dexter."
        let superclass_dot_class_name = instruction_superclass_name + instruction_class_name
        this.update_instruction_name_and_args(superclass_dot_class_name)
    }

    static make_instruction_name_html() {
        let instruction_superclass_html = "<input id='mi_instruction_superclass_name_id' title='Instruction Robot superclass'               onchange='MakeInstruction.update_instruction_name_and_args()' style='width:50px;margin-left:5px;vertical-align:25%;font-size:14px;'/>"
        let instruction_instance_html   = "<div   id='mi_instruction_instance_name_id'   title='Instruction Robot instance\nUsually empty.' onchange='MakeInstruction.update_instruction_name_and_args()' style='margin-left:0px;vertical-align:0%;font-size:14px;display:inline-block;'></div>" //set width in "show" method in jqxComboBox init
        let instruction_class_html      = "<input id='mi_instruction_class_name_id'      title='Instruction Robot class'                    onchange='MakeInstruction.update_instruction_name_and_args()' style='width:200px;margin-left:0px;vertical-align:25%;font-size:14px;'/>"
        return instruction_superclass_html + " <span style='font-size:25px;'>.</span>\n" +
               instruction_instance_html   + " <span style='font-size:25px;'>.</span>\n" +
               instruction_class_html + "\n"
    }

    static disable_instruction_name_onchange(){
        mi_instruction_superclass_name_id.onchange = ""
        mi_instruction_instance_name_id.onchange = ""
        mi_instruction_class_name_id.onchange = ""
    }
    static enable_instruction_name_onchange(){
        mi_instruction_superclass_name_id.onchange = 'MakeInstruction.update_instruction_name_and_args()'
        mi_instruction_instance_name_id.onchange   = 'MakeInstruction.update_instruction_name_and_args()'
        mi_instruction_class_name_id.onchange      = 'MakeInstruction.update_instruction_name_and_args()'
    }
    static update_instruction_name_ui(instruction_name=""){ //instruction_name looks like "Dexter.move_all_joints" or "Dexter.dexter0.move_all_joints"
        this.disable_instruction_name_onchange() //if I don't do this, I get an infinite loop
        let arr = MiIns.instruction_name_to_array_of_3(instruction_name)
        if(instruction_name == "") {
            mi_instruction_superclass_name_id.value = ""
            mi_instruction_class_name_id.value = ""
        }
        else {
            mi_instruction_superclass_name_id.value = arr[0]
            mi_instruction_class_name_id.value = arr[2]
        }
        this.update_instruction_name_robot_instance_choices(arr[1])
        this.enable_instruction_name_onchange()
    }

    static update_instruction_name_robot_instance_choices(instance_name = ""){
        $("#mi_instruction_instance_name_id").jqxComboBox('clear')
        $("#mi_instruction_instance_name_id").jqxComboBox('addItem', "")
        let superclass_name = this.get_superclass_name_from_ui()
        let rob_superclass = value_of_path(superclass_name)
        if((rob_superclass) && (Array.isArray(rob_superclass.all_names))){
            for(let rob_instance_name of rob_superclass.all_names){
                $("#mi_instruction_instance_name_id").jqxComboBox('addItem', rob_instance_name)
            }
        }
        $("#mi_instruction_instance_name_id").jqxComboBox('selectItem', instance_name)
    }
    //returns true or false. If false, it also prints an error message.
    static validate_instruction_name_ui(instruction_name="get_from_ui"){
        if(instruction_name == "get_from_ui") { instruction_name = this.get_instruction_name_from_ui() }
        let superclass_name  = this.get_superclass_name_from_ui()
        let instance_name    = this.get_instance_name_from_ui() //usually ""
        let class_name       = this.get_class_name_from_ui()
        let is_valid_instruction_name = MiIns.valid_instruction_name(instruction_name)
        if(superclass_name != ""){
            if (!window[superclass_name]){
                this.set_border_color_of_arg("mi_instruction_superclass_name_id", "red")
                out("<span style='color:red'>Error: </span>" +
                    "The instruction superclass name: <code>" + superclass_name + "</code> can't be evaluated.<br/>" +
                    "Please correct errors and try again.")
                return false
            }
            else { //superclass is present and ok
                if (Robot.is_valid_robot_class_name(superclass_name) &&
                    !Robot.robot_instances_exist_for_running_instructions_of_superclass(superclass_name)){
                    warning("No instance of Robot class: <code style='color:black;'>" + superclass_name + "</code> exists.<br/>" +
                            "You'll have to create one before running instructions on it.<br/>" +
                            "The <button>Instruction&#9660;</button> menu, <b style='color:black;'>Misc</b> submenu<br/>" +
                            "contains items to create Robot instances.")
                }
                if (instance_name != "")
                    if(!value_of_path(superclass_name + "." + instance_name)){
                        this.set_border_color_of_arg("mi_instruction_instance_name_id", "red")
                        out("<span style='color:red'>Error: </span>" +
                            "The instruction instance name: <code>" + instance_name + "</code> isn't in " + superclass_name + ".<br/>" +
                            "Please correct errors and try again.")
                        return false
                    }
                    else {
                        if(class_name != "") { //got all 3, first 2 ok
                           if(!is_valid_instruction_name){
                                this.error_for_class_name(class_name)
                                return false
                            }
                        }
                    }
                else { //superclass_name present and ok, no instance_name
                    if(class_name != "") {
                        if(!is_valid_instruction_name){
                            this.error_for_class_name(class_name)
                            return false
                        }
                    }
                }
            }
        }
        else{ //no superclass, presumably no instance_name
            if(class_name != "") {
                if(!is_valid_instruction_name) {
                    this.error_for_class_name(class_name)
                    return false
                }
            }
        }
        //if we haven't returned by now, all is good
        this.set_border_color_of_arg("mi_instruction_superclass_name_id")
        this.set_border_color_of_arg("mi_instruction_instance_name_id")
        this.set_border_color_of_arg("mi_instruction_class_name_id")
        return true
    }

    static error_for_class_name(class_name){
        this.set_border_color_of_arg("mi_instruction_class_name_id", "red")
        out("<span style='color:red'>Error: </span>" +
            "The class name: <code>" + class_name +
            "</code> is not valid.<br/>" +
            "Correct errors and try again.")
    }

   //returns format of "Dexter.dexter0.move_all_joints",
   //"Dexter.move_all_joints"
   //"some_fn"
    static get_instruction_name_from_ui(){
        let superclass_name = this.get_superclass_name_from_ui()
        let instance_name   = this.get_instance_name_from_ui()
        let class_name      = this.get_class_name_from_ui()
        return MiIns.make_instruction_name(superclass_name, instance_name, class_name)
    }

    static get_superclass_name_from_ui(){
        return mi_instruction_superclass_name_id.value
    }

    static get_instance_name_from_ui(){
        let result = $("#mi_instruction_instance_name_id").jqxComboBox("getSelectedItem")
        if ((result === null) || (result === undefined)) { return "" }
        else { return result.label }
    }

    static get_class_name_from_ui(){
        return mi_instruction_class_name_id.value
    }

    // call_obj can be just a string of the fn name,
    // or a call_obj with an instruction_name
    // or undefined (as when user types ENTER when in the instruction name field
    //called when the instruction name is changed.
    //beware sometimes happens automagically.
    static update_instruction_name_and_args(call_obj_or_instruction_name, show_doc=true){
        let old_call_object = this.make_call_obj_from_ui() //beware, this might have new instruction name, but we're just using this for its args
        MiIns.prev_defaults.merge_in(old_call_object)
        let instruction_name, call_obj
        if (call_obj_or_instruction_name === undefined) {
            instruction_name = this.get_instruction_name_from_ui()
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
            call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_pipeline()
        }
        else if (typeof(call_obj_or_instruction_name) == "string"){
            instruction_name = call_obj_or_instruction_name
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
            call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_pipeline()
        }
        else if (typeof(call_obj_or_instruction_name) == "object"){
            call_obj = call_obj_or_instruction_name
            instruction_name = call_obj.get_instruction_name()
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
        }
        else { shouldnt("in update_instruction_name_and_args passed invalid: " + call_obj_or_instruction_name) }
        //now instruction_name and call_obj set with call_obj having a name and all its args.
        this.update_instruction_name_ui(instruction_name)
        //this.validate_instruction_name_ui() //alread done above
        //this.update_instruction_name_robot_instance_choices(call_obj.instance_name) //needs to be after update & validate instruction_name
        //this probably never happens:  if (!call_obj.args_obj) { this.fill_in_call_obj_args_from_name(call_obj) }
        this.update_instruction_args(call_obj)
        this.install_replace_args_menu_items()
        if(show_doc){
            let id = instruction_name + "_doc_id"
            if(window[id]) { open_doc(id) }
        }
    }

    static update_instruction_args_for_function_html(call_obj){
        let id = this.arg_name_to_dom_elt_id("name")
        let name_src  = call_obj.args_obj.name
        let name_html = "<div style='margin:5px;white-space:nowrap;'>name: <input class='mi_arg_val_src' placeholder='do_list functions don&apos;t need names.' style='width:300px;font-size:13px;' id='" + id + "' value='" + name_src + "'/></div>"
        id = this.arg_name_to_dom_elt_id("...params")
        let params_src  = call_obj.args_obj["...params"]
        let params_html = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>...params:</span>\n" +
            "<textarea class='mi_arg_val_src' rows='2' placeholder='Ex: arg_name1, arg_name2=default_value\nbut do_list functions aren&apos;t passed arguments.' style='width:300px;font-size:13px;' id='" +
            id + "'>" + params_src + "</textarea>\n" +
            "</div>"
        id = this.arg_name_to_dom_elt_id("body")
        let body_src  = call_obj.args_obj.body
        let body_html = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>body:</span>\n" +
            `<textarea class='mi_arg_val_src' rows='4' placeholder='When a function definition in a do_list is called,\nthe "this" variable is bound to the job.' style='width:300px;font-size:13px;' id='` +
            id + "'>" + body_src + "</textarea>\n" +
            "</div>"
        let args_html = name_html + params_html + body_html
        return  args_html
    }

    static update_instruction_args(call_obj){
        let args_html = ""
        let instruction_name = call_obj.get_instruction_name()
        let family_class = MiIns.instruction_name_to_family_class(instruction_name)
        if (family_class == MiIns.function_family){
            args_html = this.update_instruction_args_for_function_html(call_obj)
        }
        else if((family_class == MiIns.move_all_joints_family) &&
                 call_obj.args_obj.hasOwnProperty("joint1")){
            for(let j=1; j < 8; j++){
                let arg_name = "joint" + j
                let arg_val_src = call_obj.args_obj[arg_name]
                if(arg_val_src === undefined) { arg_val_src = "0" }
                args_html += this.make_arg_html(arg_name, arg_val_src)
            }
        }
        else { //handles the 1 arg case of move_all_joints and most other instructions
            for(let arg_name of Object.getOwnPropertyNames(call_obj.args_obj)){
                //handles xyz arg of move_to family
                if(((arg_name == "xyz") || (arg_name == "delta_xyz")) &&
                    call_obj.args_obj.hasOwnProperty("x")) {
                    for(let arg_name of ["x", "y", "z"]){
                        let arg_val_src = call_obj.args_obj[arg_name]
                        if(arg_val_src === undefined) { arg_val_src = "0" }
                        args_html += this.make_arg_html(arg_name, arg_val_src)
                    }
                }
                //handles most args
                else {
                    let arg_val_src = call_obj.args_obj[arg_name]
                    if(arg_val_src === undefined) { arg_val_src = "" }
                    args_html += this.make_arg_html(arg_name, arg_val_src)
                }
            }
        }
        mi_args_id.innerHTML = args_html
    }

    static make_arg_html(arg_name, arg_val_src){
        let id = this.arg_name_to_dom_elt_id(arg_name)
        if(arg_name.startsWith("...") ||
           ["do_list", "body"].includes(arg_name) ||
           arg_val_src.includes("\n")){
           let placeholder = 'Separate rest args with a comma.'
           if (arg_name == "body") { placeholder = "separate statements with newline or semicolon."}
           let rows = 4
           if(arg_name == "...params") { rows = 2 }
            let result = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>" + arg_name + ":</span>\n" +
                         "<textarea class='mi_arg_val_src' rows='" + rows + "' placeholder='" + placeholder + "' style='width:300px;font-size:13px;' id='" + id + "'>" + arg_val_src + "</textarea>\n" +
                          "</div>"
            return result
        }
        else {
            return "<div style='margin:5px;white-space:nowrap;'>" + arg_name + ": <input class='mi_arg_val_src' style='width:300px;font-size:13px;' id='" + id + "' value='" + arg_val_src + "'/></div>"
        }
    }

    //_______replace args_________
    static replace_args_wrapper_html(call_obj){
        return "<div id='mi_replace_args_wrapper_id'></div>"
    }

    static install_replace_args_menu_items(){
        let instruction_name = this.get_instruction_name_from_ui()
        let family_class = MiIns.instruction_name_to_family_class(instruction_name)
        let the_html = this.make_menu_item_html("Defaults",         "MakeInstruction.replace_arg_vals_with_defaults()", "Values from the insruction's defaults.")
        if(family_class == MiIns.move_all_joints_family){
            the_html += this.make_menu_item_html("HOME",            "MakeInstruction.replace_arg_vals_maj_angles(Dexter.HOME_ANGLES)",    "Straight up.")
            the_html += this.make_menu_item_html("NEUTRAL",         "MakeInstruction.replace_arg_vals_maj_angles(Dexter.NEUTRAL_ANGLES)", "Between HOME and PARKED.")
            the_html += this.make_menu_item_html("PARKED",          "MakeInstruction.replace_arg_vals_maj_angles(Dexter.PARKED_ANGLES)",  "Folded compactly.")

            the_html += this.make_menu_item_html("convert to move_to", "MakeInstruction.replace_arg_vals_maj_convert_to_mt()", "make a move_to instruction\nwith args that cause Dexter\nto move to the same position\nthat this move_all_joints specifies.")
            the_html += this.make_menu_item_html("get from Dexter", "MakeInstruction.replace_arg_vals_maj_get_from_dexter()", "Joint angles from Dexter's current position.")
        }
        else if(family_class == MiIns.move_to_family){
            the_html += this.make_menu_item_html("HOME",            "MakeInstruction.replace_arg_vals_mt_angles(Dexter.HOME_ANGLES)",    "Straight up.")
            the_html += this.make_menu_item_html("NEUTRAL",         "MakeInstruction.replace_arg_vals_mt_angles(Dexter.NEUTRAL_ANGLES)", "Between HOME and PARKED.")
            the_html += this.make_menu_item_html("PARKED",          "MakeInstruction.replace_arg_vals_mt_angles(Dexter.PARKED_ANGLES)",  "Folded compactly.")

            the_html += this.make_menu_item_html("convert to move_all_joints", "MakeInstruction.replace_arg_vals_mt_convert_to_maj()", "make a move_all_joints instruction\nwith args that cause Dexter\nto move to the same position\nthat this move_to specifies.")
            the_html += this.make_menu_item_html("get from Dexter", "MakeInstruction.replace_arg_vals_mt_get_from_dexter()")
        }
        //replace_args_menu_items_id.innerHTML = the_html //fails
        let html_wrapper =  "<div id='mi_replace_args_id' " +
                                 "class='dde_menu' " +
                                 "style='display:inline-block;height:10px;padding:0px;margin-top:5px;'>" +
                                 "<ul style='display:inline-block;padding:0;margin-top:0px;'>" +
                                                        "<li id='mi_replace_args_label_id'>Replace Arg Values With ...&#9660;" +
                                                            "<ul id='replace_args_menu_items_id'>" +
                                                            the_html +
                            "</ul></li></ul></div>"
        mi_replace_args_wrapper_id.innerHTML = html_wrapper

        setTimeout(function(){
                    $("#mi_replace_args_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' })
                    $("#mi_replace_args_id").jqxMenu('setItemOpenDirection', 'mi_replace_args_label_id', 'right', 'up')
                   },
                   200)
    }

    //if action_string has inner quotes, they must be single quotes
    static make_menu_item_html(label_string, action_string, tooltip=""){
        return `<li title="` + tooltip + `" onclick="` + action_string + `">` + label_string + "</li>"
    }

    //______All the replace menu items that go on all families_______
    //the action for the "Defaults" menu item.
    static replace_arg_vals_with_defaults(){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_from_instruction_def()
        this.update_instruction_args(call_obj)
    }

    //______All the replace menu items that go on move_all_joints_family_______
    static replace_arg_vals_maj_angles(angles){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(instruction_name, angles)
        MakeInstruction.update_instruction_args(call_obj)
    }
    static replace_arg_vals_maj_get_from_dexter(){
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        new Job({name: "get_from_dexter",
                 robot: job_wrapper_robot,
                 when_stopped: function(){
                                 let instruction_name = MakeInstruction.get_instruction_name_from_ui()
                                 let angles = new RobotStatus({robot_status: last(this.rs_history)}).measured_angles(7)
                                 let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(instruction_name, angles)
                                 MakeInstruction.update_instruction_args(call_obj)
                 }
        }).start()
    }
    static replace_arg_vals_maj_convert_to_mt(){
        let new_instruction_name = "Dexter.move_to"
        let old_call_obj = this.make_call_obj_from_ui()
        let angles = old_call_obj.get_angle_array()
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(new_instruction_name, angles, job_wrapper_robot)
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    //______All the replace menu items that go on move_to_family_______
    static replace_arg_vals_mt_angles(angles){
        let instruction_name = this.get_instruction_name_from_ui()
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(instruction_name, angles, job_wrapper_robot)
       /* let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name)
        let [xyz, J5_direction, config] =
            Kin.J_angles_to_xyz(angles, job_wrapper_robot.pose)
        call_obj.args_obj.xyz            = to_source_code({value: xyz})
        call_obj.args_obj.J5_direction   = to_source_code({value: J5_direction})
        call_obj.args_obj.config         = to_source_code({value: config})
        call_obj.args_obj.workspace_pose = to_source_code({value: job_wrapper_robot.pose})
        call_obj.args_obj.j6_angle       = to_source_code({value: angles[6 - 1]})
        call_obj.args_obj.j7_angle       = to_source_code({value: angles[7 - 1]})
        */
        MakeInstruction.update_instruction_args(call_obj)
    }
    static replace_arg_vals_mt_get_from_dexter(){
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        new Job({name: "get_from_dexter",
            robot: job_wrapper_robot,
            when_stopped: function(){
                let instruction_name = MakeInstruction.get_instruction_name_from_ui()
                let angles = new RobotStatus({robot_status: last(this.rs_history)}).measured_angles(7)
                let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(instruction_name, angles, job_wrapper_robot)
                MakeInstruction.update_instruction_args(call_obj)
            }
        }).start()
    }

    static replace_arg_vals_mt_convert_to_maj(){
        let new_instruction_name = "Dexter.move_all_joints"
        let old_call_obj = this.make_call_obj_from_ui().merge_in_from_instruction_def_only_if_empty() //a move_to family
        if(old_call_obj.args_obj.j6_angle == "[0]") { old_call_obj.args_obj.j6_angle = "" } //both mean the same thing bug empty looks simpler in the dialog.
        if(old_call_obj.args_obj.j7_angle == "[0]") { old_call_obj.args_obj.j7_angle = "" }

        let xyz_src = old_call_obj.args_obj.xyz
        if(!xyz_src) {
            xyz_src = "[" + old_call_obj.args_obj.x + ", " +
                            old_call_obj.args_obj.y + ", " +
                            old_call_obj.args_obj.z +
                      "]"
        }
        let xyz
        try{ xyz = window.eval(xyz_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling xyz source of: " +
                     xyz_src + " errored with: " + err.message) }
        if(!Array.isArray(xyz)) {
            dde_error("While converting move_to to move_all_joints, evaling xyz source of: " +
                       xyz_src + " returned a non-array of: " + xyz)
        }

        let j5_direction_src = old_call_obj.args_obj.J5_direction
        let j5_direction
        try{ j5_direction = window.eval(j5_direction_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling J5_direction source of: " +
                                j5_direction_src + " errored with: " + err.message) }
        if(!Array.isArray(j5_direction)) {
            dde_error("While converting move_to to move_all_joints, evaling J5_direction source of: " +
                      j5_direction_src + " returned a non-array of: " + j5_direction)
        }

        let config_src = old_call_obj.args_obj.config
        let config
        try{ config = window.eval(config_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling config source of: " +
                                config_src + " errored with: " + err.message) }
        if(!Array.isArray(config)) {
            dde_error("While converting move_to to move_all_joints, evaling config_src source of: " +
                config_src + " returned a non-array of: " + config)
        }

        let angles = Kin.xyz_to_J_angles(xyz, j5_direction, config)

        let j6_angle_src = old_call_obj.args_obj.j6_angle
        let j6_angle
        if(j6_angle_src != "") { try{ j6_angle = window.eval(j6_angle_src)}
                            catch(err) { dde_error("While converting move_to to move_all_joints, evaling j6_angle source of: " +
                                j6_angle_src + " errored with: " + err.message) }
                         }
         else j6_angle = undefined
        angles.push(j6_angle)

        let j7_angle_src = old_call_obj.args_obj.j7_angle
        let j7_angle
        if(j7_angle_src != "") { try{ j7_angle = window.eval(j7_angle_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling j7_angle source of: " +
                                j7_angle_src + " errored with: " + err.message) }
        }
        else j7_angle = undefined
        angles.push(j7_angle)

        angles.push(old_call_obj.args_obj.j6_angle)
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(new_instruction_name, angles, job_wrapper_robot)
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    static bottom_buttons_html(){
        return  "<div style='white-space:nowrap;' ><button style='margin:3px;' onclick='MakeInstruction.eval_instruction()' " +
            "title='Eval the instruction.&#013;This is a good (but incomplete) test&#013;of the validity of the arguments.'>Eval Instr</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.run()' " +
            "title='Make a job with the instruction in it&#013;and start the job.'>Run</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.insert_job()' " +
            "title='Into the Editor,&#013;insert the definition of a job&#013;with the instruction in it.'>Insert Job</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.insert_instruction()' " +
            "title='If there is a selection in the Editor,&#013;replace it,&#013;otherwise just insert the instruction.'>Insert</button>" +
            "</div>"
    }

    static make_call_obj_from_ui(){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name)
        /*let param_names = this.param_names_from_ui(instruction_name)
        for(let param_name of param_names){ //fails when we call this method from after instructio_name\
            //is channged in the UI, but before the args are set as we need to when grabbing prev values
            let id = this.arg_name_to_dom_elt_id(param_name)
            let elt = window[id]
            let arg_val_src = elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            call_obj.args_obj[param_name] = arg_val_src
        }
        */
        for(let elt of mi_args_id.getElementsByClassName('mi_arg_val_src')){
            let arg_name = this.dom_elt_id_to_arg_name(elt.id)
            let arg_val_src = elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            call_obj.args_obj[arg_name] = arg_val_src
        }
        return call_obj
    }

    //obsolete feb 21, 2019
    static param_names_from_ui(instruction_name){
        if(this.dialog_contains_move_all_joints_with_joints()){
            return ["joint1", "joint2", "joint3","joint4","joint5","joint6","joint7"]
        }
        let arg_name_val_src_pairs = function_param_names_and_defaults_array(instruction_name, true)
        let param_names = []
        for(let pair of arg_name_val_src_pairs) { param_names.push(pair[0]) }
        let mt_separate_xyzs = this.dialog_contains_move_to_with_separate_xyzs()
        if (mt_separate_xyzs){
            if(param_names[0] == "xyz") { param_names.shift() }
            else { shouldnt("no first 'xyz' param in dialog_to_instruction_src with instruction: " + instruction_name +
                " and param_names: " + param_names) }
            param_names.unshift("z")
            param_names.unshift("y")
            param_names.unshift("x")

        }
        if(starts_with_one_of(instruction_name, ["Dexter.", "Serial."]) && (last(param_names) == "robot")) {
            param_names.pop() //user should be using robot instance as subject, not as last arg
            //else { shouldnt("no last 'robot' param_name in dialog_to_instruction_src with instruction: " + instruction_name +
            //                " and param_names: " + param_names)  }
        }
        return param_names
    }

    //if eval_args is true, test the instruction name and arg src.
    //by evaling it. If it errors, print a good error message,
    //highlight the approirate field in the dialog,
    //and return null, otherwise return a string.
    static dialog_to_instruction_src(eval_args=false){
        if(!this.validate_instruction_name_ui()) { return false } //error messages are printed by this
        let call_obj = this.make_call_obj_from_ui()
        let family_class = call_obj.get_family_class()
        if(family_class == MiIns.function_family) {
          return this.dialog_to_instruction_src_for_function(eval_args, call_obj)
        }
        else if(family_class == MiIns.array_family){
            return this.dialog_to_instruction_src_for_array(eval_args, call_obj)
        }
        else { return this.dialog_to_instruction_src_for_normal(eval_args, call_obj) }
    }

    static dialog_to_instruction_src_for_normal(eval_args=false, call_obj){
        let family_of_instruction = call_obj.get_family_class()
        let instruction_name = call_obj.get_instruction_name()
        let result = instruction_name + "("
        let maj_with_joints  = this.dialog_contains_move_all_joints_with_joints()
        if(maj_with_joints) { result += "[" }
        let fn = call_obj.get_instruction_class()
        let fn_is_keyword = fn_is_keyword_fn(fn)
        if(fn_is_keyword) { result += "{\n" }
        let arg_name_val_src_pairs = function_param_names_and_defaults_array(instruction_name, true)
        let param_names = Object.getOwnPropertyNames(call_obj.args_obj)
        let src_before_undefined = result
        for(let param_name of param_names){
            let arg_default_val_src = this.find_arg_val_src_in_arg_name_val_src_pairs(param_name, arg_name_val_src_pairs)
            if((family_of_instruction == MiIns.move_all_joints_family) &&
               param_name.startsWith("joint") &&
               (arg_default_val_src == undefined)) {
                arg_default_val_src = ""
            }
            let id = this.arg_name_to_dom_elt_id(param_name)
            let elt = window[id]
            let arg_val_src = elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            if(eval_args){
                if(!this.validate_arg_ui(instruction_name, param_name, arg_val_src)) { return null }
            }
            let arg_val_is_default = false
            if (arg_val_src === "") { //typein is empty so use the default val
                arg_val_src = arg_default_val_src
                arg_val_is_default = true
            }
            else if(arg_val_src == arg_default_val_src) { arg_val_is_default = true }
            else if(arg_val_src == "undefined")         { arg_val_is_default = true }

            let did_insert_arg   = true
            let mt_separate_xyzs = this.dialog_contains_move_to_with_separate_xyzs()
            if (mt_separate_xyzs && (param_name == "x")) {
                if(fn_is_keyword)                            { result += "xyz: [" + arg_val_src }
                else                                         { result += "[" + arg_val_src }
            }
            else if(mt_separate_xyzs && (param_name == "y")) { result += arg_val_src }
            else if(mt_separate_xyzs && (param_name == "z")) { result += arg_val_src + "]"}
            else if(fn_is_keyword){
                    if(!arg_val_is_default || mi_insert_default_args_id.checked)  {
                       if(param_name == "do_list"){
                           arg_val_src = "\n        " + arg_val_src.trim() //8 spaces (2 tabs)
                       }
                                                                    result += "    " + param_name + ": " + arg_val_src
                    }
                    else { did_insert_arg = false }                                         //insert nothing
            }
            else  {                                                 result += arg_val_src }
            if (!(last(param_names) == param_name) && did_insert_arg) {
                if(fn_is_keyword) { result += ",\n" }
                else              { result += ", " }
            }
            if(!arg_val_is_default || mi_insert_default_args_id.checked) {
                src_before_undefined = result   //don't include in src trailing undefineds
            }
        }
        //get rid of extra whitespace and comma at the end, otherwise option-click fails on parsing, even though now js ok with extra comma.
        src_before_undefined = trim_end(src_before_undefined)
        if(src_before_undefined.endsWith(",")) {
            src_before_undefined = src_before_undefined.substring(0, src_before_undefined.length - 1)
        }
        if(maj_with_joints) {
            src_before_undefined += "]"
        }
        if(fn_is_keyword) { src_before_undefined += "}" }
        result = src_before_undefined + ")"
        return result
    }

    static validate_arg_ui(instruction_name, param_name, arg_val_src){
        if ((instruction_name == "new Job") && (param_name == "do_list")){
            let ast
            try{ ast = MiParser.string_to_ast(arg_val_src)}
            catch(err){
                this.set_border_color_of_arg(param_name, "red")
                let short_arg_val_src = ((arg_val_src.length > 60) ? arg_val_src.substring(0, 60) + "..." : arg_val_src)
                out("<span style='color:red'>Error: </span>" +
                    "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                    "with source of: " +
                    "<code style='padding:3px;'>" + short_arg_val_src + "</code><br/>" +
                    "errored because <span style='color:red;'>" + err.message +
                    "</span><br/>Correct errors and try again.")
                return null
            }
            let body0_expression_ast = ast.body[0].expression
            if(body0_expression_ast.type == "ArrayExpression"){
                let elts_array = body0_expression_ast.elements
                for(let i = 0; i < elts_array.length; i++){
                    let elt_ast = elts_array[i]
                    let elt_src = arg_val_src.substring(elt_ast.range[0], elt_ast.range[1])
                    try{
                        let do_list_item = window.eval(elt_src)
                        if(!Instruction.is_do_list_item(do_list_item)){
                            this.set_border_color_of_arg(param_name, "red")
                            out("<span style='color:red'>Error: </span>" +
                                "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                                "element " + i + " (zero based) of " + elts_array.length + " with source of:<br/>" +
                                "<code style='padding:3px;'>" + elt_src + "</code><br/>" +
                                "errored because it evaled to: " + do_list_item + "<br/>" +
                                "and <span style='color:red;'> that is not a valid do_list item." +
                                "</span><br/>Correct errors and try again.")
                            open_doc(do_list_doc_id)
                            return null
                        }
                    }
                    catch(err){
                        this.set_border_color_of_arg(param_name, "red")
                        out("<span style='color:red'>Error: </span>" +
                            "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                            "element " + i + " (zero based) of " + elts_array.length + " with source of:<br/>" +
                            "<code style='padding:3px;'>" + elt_src + "</code><br/>" +
                            "errored because:" + "<span style='color:red;'> " + err.message +
                            "</span><br/>Correct errors and try again.")
                        return null
                    }
                }
            }
        }
        else {
            try{
                window.eval(arg_val_src)
                this.set_border_color_of_arg(param_name)
            }
            catch(err){
                this.set_border_color_of_arg(param_name, "red")
                out("<span style='color:red'>Error: </span>" +
                    "In <i>Make Instruction</i>, evaling the <b>" + param_name + "</b> source of:<br/>" +
                    "<code style='padding:3px;'>" + arg_val_src + "</code><br/>errored because:" +
                    "<span style='color:red;'> " + err.message +
                    "</span><br/>Correct errors and try again.")
                return null
            }
        }

    }

    //instruction_name is either "function" or "function*"
    //note that this method ignores eval_args because
    //none of the "args" are really evalable.
    static dialog_to_instruction_src_for_function(eval_args=false){
        let instruction_name = this.get_instruction_name_from_ui()
        let id
        let elt
        id = this.arg_name_to_dom_elt_id("name")
        elt = window[id]
        let the_name_src = elt.value.trim()
        id = this.arg_name_to_dom_elt_id("...params")
        elt = window[id]
        let the_params_src = elt.value.trim()
        id = this.arg_name_to_dom_elt_id("body")
        elt = window[id]
        let the_body_src  = elt.value.trim()
        the_body_src = "\n" + the_body_src
        the_body_src = replace_substrings(the_body_src, "\n", "\n    ")

        let result = ((the_name_src == "") ? instruction_name: instruction_name + " " + the_name_src )
        result += "(" + the_params_src + "){" + the_body_src + "\n}\n"
        return result
    }

    static dialog_to_instruction_src_for_array(eval_args=false){
        let param_name = "...elts"
        let id = this.arg_name_to_dom_elt_id(param_name)
        let elt = window[id]
        let args_val_src = elt.value.trim()
        if(eval_args){
            let arg_val_src_array = args_val_src.split(",")
            for(let i = 0; i < arg_val_src_array.length; i++){
                let arg_val_src = arg_val_src_array[i]
                try{
                    window.eval(arg_val_src)
                    this.set_border_color_of_arg(param_name)
                }
                catch(err){
                    this.set_border_color_of_arg(param_name, "red")
                    out("<span style='color:red'>Error: </span>" +
                        "In <i>Make Instruction</i>, evaling the <b>" + param_name + "</b> source at index " + i + " of<br/>" +
                        "<code style='padding:3px;'>" + arg_val_src + "</code><br/>errored because:" +
                        "<span style='color:red;'> " + err.message +
                        "</span><br/>Correct errors and try again.")
                    return null
                }
            }
        }
        return "[" + args_val_src + "]"
    }

    static eval_instruction(){
        let src = this.dialog_to_instruction_src(true)
        if(src !== null) {
            src = this.fix_src_of_function_maybe(src)
            eval_js_part2(src)
        }
    }

    static fix_src_of_function_maybe(src) {
        let instruction_name = this.get_instruction_name_from_ui()
        if (MiIns.instruction_name_in_family_class(instruction_name, MiIns.function_family)) {
            src = "(" + src + ")" //due to js design mistake,
                                  //anonymous fn defs can't be evaled without
                                  //wrapping them in parens.
                                  //we might have a NAMED fn here, but the parens
                                  //are harmless for that.
        }
        return src
    }

    static run(){
        let call_obj = this.make_call_obj_from_ui() //don't reshow th inst_src becasue that goes through te pipelinne
           //which merges in prev values, etc. which we don't want.
        let inst_src = this.dialog_to_instruction_src()
        if(!this.src_looks_like_valid_instruction(inst_src)){
            if(starts_with_one_of(inst_src, "new Dexter(", "new Serial(")){
                warning("You've created a Robot in the Make Instruction dialog.<br/>" +
                    "A Robot isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            else {warning("The code you've created in the Make Instruction dialog<br/>" +
                    "isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            return
        }
        inst_src = this.fix_src_of_function_maybe(inst_src)
        let the_inst = eval(inst_src)
        let robot_of_wrapper = value_of_path(mi_job_wrapper_robot_name_id.value)
        let job_00
        if((this.get_instruction_name_from_ui() == "new Job") &&
            robot_of_wrapper == the_inst.robot) {
            warning("When using a Job as an instruction (to start it),<br/>" +
                    "its robot must be different than the Job its in.<br/>" +
                    "They are the same in this case so this use of the Run button<br/>" +
                    "didn't wrap the new Job instruction you specified in another Job before running it.")
            job_00 = the_inst
        }
        else {
            let job_wrapper_robot_name = mi_job_wrapper_robot_name_id.value
            job_00 = new Job({name: "job_00",
                              robot: value_of_path(job_wrapper_robot_name),
                              do_list: [the_inst],
                              when_stopped: function(){
                                               setTimeout(function() { MakeInstruction.show(call_obj, job_wrapper_robot_name, false) },
                                                          2000)
                                            }
                     })
        }
        let true_or_error_mess = Instruction.can_instruction_run_on_robot(the_inst, robot_of_wrapper)
        if(typeof(true_or_error_mess) == "string") {
            dde_error(true_or_error_mess)
        }
        else if(Robot.simulate_or_both_selected()){
            misc_pane_menu_changed("Simulate Dexter")
            //to give user time to adjust to the sim pane
            setTimeout(function() { job_00.start() },
                       2000)
        }
        else {  job_00.start() } //don't switch to simulator if we're not simulating
    }
    //static run_after_delay(the_job){
    //    the_job.start()
    //}

    static insert_instruction(){
        let src = this.dialog_to_instruction_src()
        let suffix = ""
        if(Editor.is_selection()) { Editor.replace_selection(src)} //trailing comma ok inside of an array
        else {
            let suffix
            if(this.src_looks_like_valid_instruction(src)){ //these are not valid instructions, so can't be in a do_list, so shouldn't be followed by a comma
                suffix = ",\n    "
            }
            else { suffix = "\n"}
            Editor.insert(src + suffix)
        }
    }
    static insert_job(){
        let inst_src = this.dialog_to_instruction_src()
        if(!this.src_looks_like_valid_instruction(inst_src)){
            if(starts_with_one_of(inst_src, "new Dexter(", "new Serial(")){
                warning("You've created a Robot in the Make Instruction dialog.<br/>" +
                    "A Robot isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            else {warning("The code you've created in the Make Instruction dialog<br/>" +
                "isn't valid as a Job's do_list item.<br/>" +
                "You can, however, Eval it and Insert it into the editor.")
            }
            return
        }
        let robot_name = mi_job_wrapper_robot_name_id.value
        let robot_line = ""
        if(robot_name != "Dexter.dexter0"){
            robot_line = '    robot: ' + mi_job_wrapper_robot_name_id.value + ',\n'
        }
        let job_src = '\nnew Job({' +
        '\n    name: "my_job",\n' +
              robot_line +
        '    do_list: [' +
        '\n        ' + inst_src +
        '\n    ]})\n'
        Editor.insert(job_src)
    }
} //end class



MakeInstruction.menu_hierarchy = [
    ["Dexter move",  "move_all_joints", "move_all_joints_relative",
                     "move_home",
                     "move_to", "move_to_relative", "move_to_straight",
                     "pid_move_all_joints", "pid_move_to"],
    ["Dexter mode",  "set_follow_me", "set_force_protect", "set_keep_position", "set_open_loop"],
    ["Dexter common", "draw_dxf", "empty_instruction_queue_immediately", "empty_instruction_queue",
                      "get_robot_status", "get_robot_status_immediately", "make_ins", "read_from_robot",
                      "run_gcode", "set_parameter", "write_to_robot"],
    ["Dexter rare", "capture_ad", "capture_points", "cause_error", "dma_read", "dma_write", "exit",
                    "find_home", "find_home_rep", "find_index", "load_tables",
                    "record_movement", "replay_movement",
                    "sleep",  "slow_move", "write"],
    ["Human",       "enter_choice", "enter_filepath", "enter_instruction", "enter_number",
                    "enter_position", "enter_text", "notify", "show_window", "speak", "task"],
    ["Robot control", "break", "go_to", "loop","label",
                      "suspend", "unsuspend", "sync_point", "wait_until"],
    ["Robot I/O",  "get_page", "grab_robot_status",  "out",
                   "show_picture", "show_video", "take_picture"],
    ["Robot Jobs", "send_to_job", /*"sent_from_job" don't let user use this*/
                   "start_job", "stop_job"],
    ["Robot bugs", "debugger", "error", "if_any_errors"],
    ["Serial",     "string_instruction"],
    ["Misc"      , "function", "function*",
                   //"null", don't have null on menu. its a valid instruction but does nothing, hard to support, and you wouldn't explicitly put one in a job's do_list
                    "new Array", "new Job", "new Note", "new Phrase", "new TestSuite",
                   "new Dexter", "new Serial"
                   ]
]

var esprima = require('esprima')
var {ends_with_one_of, fn_is_keyword_fn, replace_substrings, starts_with_one_of, trim_end} = require("./core/utils.js")
var {to_source_code} = require("./core/to_source_code.js")