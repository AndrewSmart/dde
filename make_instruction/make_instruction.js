
var MakeInstruction = class MakeInstruction{
   //utilities

   static add_robot_to_job_wrapper_robot_menu_maybe(string_or_robot){
       if(window["mi_job_wrapper_robot_name_id"]){
           let name = string_or_robot
           if(typeof(string_or_robot) != "string") {
               name = string_or_robot.toString()
           }
           let a_option = document.createElement("option")
           a_option.innerText = name
           mi_job_wrapper_robot_name_id.prepend(a_option)
       }
   }

    //this is a lousy test. It presumes the src is valid JS and that
    //it is generated by MakeInstruction, so it just filters out
    //the few items you can make with MakeInstruction that
    //aren't valid on a do_list
    static src_looks_like_valid_instruction(src){
       if(starts_with_one_of(src, ["new Dexter(", "new Serial("])){
           return false
       }
       else { return true }
    }

    static dialog_contains_move_all_joints_with_joints(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(MiIns.instruction_name_in_family_class(instruction_name, MiIns.move_all_joints_family)){
            let id = this.arg_name_to_dom_elt_id("joint1")
            let elt = window[id]
            if(elt) { return true }
            else    { return false }
        }
        else { return false }
    }
    static dialog_contains_move_to_with_separate_xyzs(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(MiIns.instruction_name_in_family_class(instruction_name, MiIns.move_to_family)){
            let id = this.arg_name_to_dom_elt_id("x")
            let elt = window[id]
            if(elt) { return true }
            else    { return false }
        }
        else { return false }
    }

    static call_obj_arg_obj_with_name(call_obj, arg_name){
        for(let arg_obj of call_obj.args){
            if(arg_obj.name == arg_name) { return arg_obj }
        }
        dde_error("call_obj_arg_obj_with_name couldn't find: " + arg_name + " in: " + call_obj)
    }


    //you can pass "instruction_name" even though its not really an "arg"
    static arg_name_to_dom_elt_id(arg_name){
        if(arg_name.startsWith("mi_arg_")) { return arg_name }
        //if(arg_name.startsWith("...")){ arg_name = arg_name.substring(3) }
        return "mi_arg_" + arg_name + "_id"
    }

    //return a string of the source code of the named arg in the MI dialog
    //returns null if no such name
    static arg_name_to_src_in_mi_dialog(name){
       let elt = window[this.arg_name_to_dom_elt_id(name)]
       if(elt) {
           return elt.value
       }
       else { return null }
    }

    static dom_elt_id_to_arg_name(dom_elt_id){
        let end_pos = dom_elt_id.length - 3
        return dom_elt_id.substring(7, end_pos)
    }

    //the default color is transparent
    static set_border_color_of_arg(arg_name, color="rgb(238, 238, 238)"){
        let id = this.arg_name_to_dom_elt_id(arg_name)
        let elt = window[id]
        if(elt){
          elt.style.borderColor = color
        }
    }

    static clean_instruction_name(instruction_name){
        if(instruction_name.startsWith("new ")){
            instruction_name = instruction_name.substring(4).trim()
        }
        return instruction_name
    }
    //end utilities

    static find_arg_val_src_in_arg_name_val_src_pairs(arg_name, arg_name_src_pairs){
        for(let pair of arg_name_src_pairs) { if(arg_name == pair[0]) { return pair[1] } }
        return undefined
    }


    //top level fn, called when user option-clicks in editor, passed the selected src.
    //first arg can be a string of js src, or a call obj (used by MakeInstruction.run
    static show(instruction_call_src=null, selected_robot_full_name="", show_doc=true){
        misc_pane_menu_id.value = "Make Instruction"
        let call_obj
        if(typeof(instruction_call_src) == "string"){ //don't use pipeline because we don't want to merge in prev_vals when coming from the editor, just instrudtion def defaults overlayed with src values
            call_obj = MiIns.make_from_instruction_source_no_args(instruction_call_src). //just fill in instruction name
                       merge_in_from_instruction_def().
                       merge_in_src(instruction_call_src)  //do not merge in special_defaults nor prev_values
        }
        else if (instruction_call_src == null){
            call_obj = MiIns.make_from_instruction_name_no_args("Dexter.move_all_joints")
            for(let i = 1; i < 8; i++) {  //not quite the same as merge_in_special_defaults
                let arg_name = "joint" + i
                call_obj.args_obj[arg_name] = "0"
            }
        }
        else {call_obj = instruction_call_src }

        sim_pane_content_id.innerHTML =
            "<div style='background-color:#EEEEEE;margin-bottom:10px;'>" +
                "<div style='font-size:14px;font-weight:700;margin-left:50px;'>Make Instruction</div>" +
                this.make_job_robots_select_html(selected_robot_full_name) +
                "<div style='white-space:nowrap;'>" +  //white-space:nowrap;
                    this.make_instruction_menu_html() +
                    this.make_instruction_name_html() +
                "</div>" +
                "<div id='mi_args_id'></div>" +
                this.replace_args_wrapper_html(call_obj) + //"<br/>" +
                "<div style='display:inline-block;vertical-align:50%;'><input id='mi_insert_default_args_id' type='checkbox' style='margin-left:10px;'> Insert default args</input></div><br/>" +
                this.bottom_buttons_html() +
                MiRecord.make_html() +
            "</div>"
        $("#mi_instruction_menu_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' })
        $("#mi_instruction_menu_id").jqxMenu('setItemOpenDirection', 'mi_instruction_id', 'right', 'up');
        $("#mi_instruction_instance_name_id").jqxComboBox({width: '90px', height: '20px'})
        MiState.init() //if MiState.job_instance is active, (typically suspended, it stops the job, then sets
                       //MiState.job_instance to null, ensuring that, if we're bringing in a new Job def with
                       //this call to show, that new job_def will get used.
        MiRecord.init() //also calls MiState.init(), but does it with the cur MiState.job_instance which is why
                       //we needed to call MiState.init()  first. Its quick, so ok if somewhat redundant.
        MakeInstruction.update_instruction_name_and_args(call_obj, show_doc) //because call_obj isn't for a job,
                //this call won't call  MiRecord.init()
    }

    static is_shown(){
        if(window["mi_instruction_menu_id"]) { return true }
        else { return false }
    }

    static make_job_robots_select_html(selected_robot_full_name=""){
        var result = "<div style='margin-top:5px;'>Job default robot: " +
                     "<select id='mi_job_wrapper_robot_name_id' onchange='MakeInstruction.onchange_job_robot()' style='font-size:14px;width:130px;'" +
                     " title='Supplies the robot for instructions prefixed\n" +
                             "with a robot class (like Dexter or Serial)\n" +
                             "but no robot instance.')>"
        for(let robot_class_name of ["Brain", "Dexter", "Human", "Serial"]){
            for(let name of window[robot_class_name].all_names){
                let full_name = robot_class_name + "." + name
                let sel_attr = ((full_name == selected_robot_full_name) ? " selected='selected' " : "")
                result += "<option " + sel_attr + ">" + full_name + "</option>"
            }
        }
        result += "</select></div>"
        return result
    }

    static onchange_job_robot(){
       if(this.get_instruction_name_from_ui() == "new Job"){
           window[this.arg_name_to_dom_elt_id("robot")].value = mi_job_wrapper_robot_name_id.value
       }
    }

    static make_instruction_menu_item_html(label_array){
      let result = "<li>" + label_array[0] + "<ul>"
      for(let i = 1; i < label_array.length; i++){
         let label = label_array[i]  //setting the width below fails. usingn title lets you see long menu items
         let title
         if (label == "function*") { title = "generator"}
         else if (["new Dexter", "new Serial"].includes(label)) { title = "A Robot instance is not a valid do_list item." }
         else { title = label}
         result += "<li style='width:300px;' title='" + title + "' onclick='MakeInstruction.instruction_menu_click(event)'>" + label + "</li>"
      }
      result += "</ul></li>"
      return result
    }
    static make_instruction_menu_html(){
       let result = `<div title='Choose the class of instruction to make.' id='mi_instruction_menu_id' class='dde_menu' style="display:inline-block;height:15px;padding:0px;margin-top:5px;">
                      <ul style="display:inline-block;padding:0;margin-top:0px;">
                        <li id="mi_instruction_id" style="display:inline-block;padding-left:3px;padding-right:0px;">Instruction&#9660;<ul>`
       for(let labels of this.menu_hierarchy){
           result += this.make_instruction_menu_item_html(labels)
       }
       result += "</ul></li></ul></div>"
       return result
    }
    static instruction_menu_item_parent(label){
       for(let submenu_array of MakeInstruction.menu_hierarchy){
           if(submenu_array.includes(label)) { return submenu_array[0] }
       }
    }
    static instruction_menu_item_prefix(label){
        let parent_label = this.instruction_menu_item_parent(label)
        if      (parent_label.startsWith("Dexter")) { return "Dexter."}
        else if (parent_label.startsWith("Human"))  { return "Human."}
        else if (parent_label.startsWith("Robot"))  { return "Robot."}
        else if (parent_label.startsWith("Serial")) { return "Serial."}
        else { return "" }
    }

    static instruction_menu_click(event){
        let instruction_class_name = event.target.innerText // ie "move_all_joints"
        let instruction_superclass_name = this.instruction_menu_item_prefix(instruction_class_name) //ie "Dexter."
        let superclass_dot_class_name = instruction_superclass_name + instruction_class_name
        this.update_instruction_name_and_args(superclass_dot_class_name)
    }

    static make_instruction_name_html() {
        let instruction_superclass_html = "<input id='mi_instruction_superclass_name_id' title='Instruction Robot superclass'               onchange='MakeInstruction.update_instruction_name_and_args()' style='width:50px;margin-left:5px;vertical-align:25%;font-size:14px;'/>"
        let instruction_instance_html   = "<div   id='mi_instruction_instance_name_id'   title='Instruction Robot instance\nUsually empty.' onchange='MakeInstruction.update_instruction_name_and_args()' style='margin-left:0px;vertical-align:0%;font-size:14px;display:inline-block;'></div>" //set width in "show" method in jqxComboBox init
        let instruction_class_html      = "<input id='mi_instruction_class_name_id'      title='Instruction Robot class'                    onchange='MakeInstruction.update_instruction_name_and_args()' style='width:200px;margin-left:0px;vertical-align:25%;font-size:14px;'/>"
        return instruction_superclass_html + " <span style='font-size:25px;'>.</span>\n" +
               instruction_instance_html   + " <span style='font-size:25px;'>.</span>\n" +
               instruction_class_html + "\n"
    }

    static disable_instruction_name_onchange(){
        mi_instruction_superclass_name_id.onchange = ""
        mi_instruction_instance_name_id.onchange = ""
        mi_instruction_class_name_id.onchange = ""
    }
    static enable_instruction_name_onchange(){
        mi_instruction_superclass_name_id.onchange = 'MakeInstruction.update_instruction_name_and_args()'
        mi_instruction_instance_name_id.onchange   = 'MakeInstruction.update_instruction_name_and_args()'
        mi_instruction_class_name_id.onchange      = 'MakeInstruction.update_instruction_name_and_args()'
    }
    static update_instruction_name_ui(instruction_name=""){ //instruction_name looks like "Dexter.move_all_joints" or "Dexter.dexter0.move_all_joints"
        this.disable_instruction_name_onchange() //if I don't do this, I get an infinite loop
        let arr = MiIns.instruction_name_to_array_of_3(instruction_name)
        if(instruction_name == "") {
            mi_instruction_superclass_name_id.value = ""
            mi_instruction_class_name_id.value = ""
        }
        else {
            mi_instruction_superclass_name_id.value = arr[0]
            mi_instruction_class_name_id.value = arr[2]
        }
        this.update_instruction_name_robot_instance_choices(arr[1])
        this.enable_instruction_name_onchange()
    }

    static update_instruction_name_robot_instance_choices(instance_name = ""){
        $("#mi_instruction_instance_name_id").jqxComboBox('clear')
        $("#mi_instruction_instance_name_id").jqxComboBox('addItem', "")
        let superclass_name = this.get_superclass_name_from_ui()
        let rob_superclass = value_of_path(superclass_name)
        if((rob_superclass) && (Array.isArray(rob_superclass.all_names))){
            for(let rob_instance_name of rob_superclass.all_names){
                $("#mi_instruction_instance_name_id").jqxComboBox('addItem', rob_instance_name)
            }
        }
        $("#mi_instruction_instance_name_id").jqxComboBox('selectItem', instance_name)
    }
    //returns true or false. If false, it also prints an error message.
    static validate_instruction_name_ui(instruction_name="get_from_ui"){
        if(instruction_name == "get_from_ui") { instruction_name = this.get_instruction_name_from_ui() }
        let superclass_name  = this.get_superclass_name_from_ui()
        let instance_name    = this.get_instance_name_from_ui() //usually ""
        let class_name       = this.get_class_name_from_ui()
        let is_valid_instruction_name = MiIns.valid_instruction_name(instruction_name)
        if(superclass_name != ""){
            if (!window[superclass_name]){
                this.set_border_color_of_arg("mi_instruction_superclass_name_id", "red")
                out("<span style='color:red'>Error: </span>" +
                    "The instruction superclass name: <code>" + superclass_name + "</code> can't be evaluated.<br/>" +
                    "Please correct errors and try again.")
                return false
            }
            else { //superclass is present and ok
                if (Robot.is_valid_robot_class_name(superclass_name) &&
                    !Robot.robot_instances_exist_for_running_instructions_of_superclass(superclass_name)){
                    warning("No instance of Robot class: <code style='color:black;'>" + superclass_name + "</code> exists.<br/>" +
                            "You'll have to create one before running instructions on it.<br/>" +
                            "The <button>Instruction&#9660;</button> menu, <b style='color:black;'>Misc</b> submenu<br/>" +
                            "contains items to create Robot instances.")
                }
                if (instance_name != "")
                    if(!value_of_path(superclass_name + "." + instance_name)){
                        this.set_border_color_of_arg("mi_instruction_instance_name_id", "red")
                        out("<span style='color:red'>Error: </span>" +
                            "The instruction instance name: <code>" + instance_name + "</code> isn't in " + superclass_name + ".<br/>" +
                            "Please correct errors and try again.")
                        return false
                    }
                    else {
                        if(class_name != "") { //got all 3, first 2 ok
                           if(!is_valid_instruction_name){
                                this.error_for_class_name(class_name)
                                return false
                            }
                        }
                    }
                else { //superclass_name present and ok, no instance_name
                    if(class_name != "") {
                        if(!is_valid_instruction_name){
                            this.error_for_class_name(class_name)
                            return false
                        }
                    }
                }
            }
        }
        else{ //no superclass, presumably no instance_name
            if(class_name != "") {
                if(!is_valid_instruction_name) {
                    this.error_for_class_name(class_name)
                    return false
                }
            }
        }
        //if we haven't returned by now, all is good
        this.set_border_color_of_arg("mi_instruction_superclass_name_id")
        this.set_border_color_of_arg("mi_instruction_instance_name_id")
        this.set_border_color_of_arg("mi_instruction_class_name_id")
        return true
    }

    static error_for_class_name(class_name){
        this.set_border_color_of_arg("mi_instruction_class_name_id", "red")
        out("<span style='color:red'>Error: </span>" +
            "The class name: <code>" + class_name +
            "</code> is not valid.<br/>" +
            "Correct errors and try again.")
    }

   //returns format of "Dexter.dexter0.move_all_joints",
   //"Dexter.move_all_joints"
   //"some_fn"
    static get_instruction_name_from_ui(){
        let superclass_name = this.get_superclass_name_from_ui()
        let instance_name   = this.get_instance_name_from_ui()
        let class_name      = this.get_class_name_from_ui()
        return MiIns.make_instruction_name(superclass_name, instance_name, class_name)
    }

    static get_superclass_name_from_ui(){
        return mi_instruction_superclass_name_id.value
    }

    static get_instance_name_from_ui(){
        let result = $("#mi_instruction_instance_name_id").jqxComboBox("getSelectedItem")
        if ((result === null) || (result === undefined)) { return "" }
        else { return result.label }
    }

    static get_class_name_from_ui(){
        return mi_instruction_class_name_id.value
    }

    // call_obj can be just a string of the fn name,
    // or a call_obj with an instruction_name
    // or undefined (as when user types ENTER when in the instruction name field
    //called when the instruction name is changed.
    //beware sometimes happens automagically.
    static update_instruction_name_and_args(call_obj_or_instruction_name, show_doc=true){
        let old_call_object = this.make_call_obj_from_ui() //beware, this might have new instruction name, but we're just using this for its args
        MiIns.prev_defaults.merge_in(old_call_object)
        let instruction_name, call_obj
        if (call_obj_or_instruction_name === undefined) {
            instruction_name = this.get_instruction_name_from_ui()
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
            call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_pipeline()
        }
        else if (typeof(call_obj_or_instruction_name) == "string"){
            instruction_name = call_obj_or_instruction_name
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
            call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_pipeline()
        }
        else if (typeof(call_obj_or_instruction_name) == "object"){
            call_obj = call_obj_or_instruction_name
            instruction_name = call_obj.get_instruction_name()
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
        }
        else { shouldnt("in update_instruction_name_and_args passed invalid: " + call_obj_or_instruction_name) }
        //now instruction_name and call_obj set with call_obj having a name and all its args.
        this.update_instruction_name_ui(instruction_name)
        //this.validate_instruction_name_ui() //alread done above
        //this.update_instruction_name_robot_instance_choices(call_obj.instance_name) //needs to be after update & validate instruction_name
        //this probably never happens:  if (!call_obj.args_obj) { this.fill_in_call_obj_args_from_name(call_obj) }
        this.update_instruction_args(call_obj)
        this.install_replace_args_menu_items()
        if(show_doc){
            if(instruction_name.startsWith("new ")){
                instruction_name = instruction_name.substring(4)
            }
            let id = instruction_name + "_doc_id"
            if(window[id]) { open_doc(id) }
        }
        if (instruction_name == "Job") {
            window[this.arg_name_to_dom_elt_id("robot")].value = mi_job_wrapper_robot_name_id.value
            mi_run_id.title = "Start the job defined by the above fields."
            MiRecord.init_with_job_in_dialog()
        }
        else { mi_run_id.title = 'Make a job with the instruction in it\nand start the job.'}
    }

    static update_instruction_args_for_function_html(call_obj){
        let id = this.arg_name_to_dom_elt_id("name")
        let name_src  = call_obj.args_obj.name
        let name_html = "<div style='margin:5px;white-space:nowrap;'>name: <input class='mi_arg_val_src' placeholder='do_list functions don&apos;t need names.' style='width:300px;font-size:13px;' id='" + id + "' value='" + name_src + "'/></div>"
        id = this.arg_name_to_dom_elt_id("...params")
        let params_src  = call_obj.args_obj["...params"]
        let params_html = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>...params:</span>\n" +
            "<textarea class='mi_arg_val_src' rows='2' placeholder='Ex: arg_name1, arg_name2=default_value\nbut do_list functions aren&apos;t passed arguments.' style='width:300px;font-size:13px;' id='" +
            id + "'>" + params_src + "</textarea>\n" +
            "</div>"
        id = this.arg_name_to_dom_elt_id("body")
        let body_src  = call_obj.args_obj.body
        let body_html = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>body:</span>\n" +
            `<textarea class='mi_arg_val_src' rows='4' placeholder='When a function definition in a do_list is called,\nthe "this" variable is bound to the job.' style='width:300px;font-size:13px;' id='` +
            id + "'>" + body_src + "</textarea>\n" +
            "</div>"
        let args_html = name_html + params_html + body_html
        return  args_html
    }

    static update_instruction_args(call_obj){
        let args_html = ""
        let instruction_name = call_obj.get_instruction_name()
        let family_class = MiIns.instruction_name_to_family_class(instruction_name)
        if (family_class == MiIns.function_family){
            args_html = this.update_instruction_args_for_function_html(call_obj)
        }
        else if((family_class == MiIns.move_all_joints_family) &&
                 call_obj.args_obj.hasOwnProperty("joint1")){
            for(let j=1; j < 8; j++){
                let arg_name = "joint" + j
                let arg_val_src = call_obj.args_obj[arg_name]
                if(arg_val_src === undefined) { arg_val_src = "0" }
                args_html += this.make_arg_html(arg_name, arg_val_src)
            }
        }
        else { //handles the 1 arg case of move_all_joints and most other instructions
            for(let arg_name of Object.getOwnPropertyNames(call_obj.args_obj)){
                //handles xyz arg of move_to family
                if(((arg_name == "xyz") || (arg_name == "delta_xyz")) &&
                    call_obj.args_obj.hasOwnProperty("x")) {
                    for(let arg_name of ["x", "y", "z"]){
                        let arg_val_src = call_obj.args_obj[arg_name]
                        if(arg_val_src === undefined) { arg_val_src = "0" }
                        args_html += this.make_arg_html(arg_name, arg_val_src)
                    }
                }
                //handles most args
                else {
                    let arg_val_src = call_obj.args_obj[arg_name]
                    if(arg_val_src === undefined) { arg_val_src = "" }
                    args_html += this.make_arg_html(arg_name, arg_val_src)
                }
            }
        }
        mi_args_id.innerHTML = args_html
    }

    static make_arg_html(arg_name, arg_val_src){
        let id = this.arg_name_to_dom_elt_id(arg_name)
        if(arg_name.startsWith("...") ||
           ["do_list", "body"].includes(arg_name) ||
           arg_val_src.includes("\n")){
           let placeholder = 'Separate rest args with a comma.'
           if (arg_name == "body") { placeholder = "separate statements with newline or semicolon."}
           let rows = 4
           if(arg_name == "...params") { rows = 2 }
            let result = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>" + arg_name + ":</span>\n" +
                         "<textarea class='mi_arg_val_src' rows='" + rows + "' placeholder='" + placeholder + "' oninput='MiState.invalidate_job_instance()' style='width:300px;font-size:13px;' id='" + id + "'>" + arg_val_src + "</textarea>\n" +
                          "</div>"
            return result
        }
        else {
            return "<div style='margin:5px;white-space:nowrap;'>" + arg_name + ": <input class='mi_arg_val_src' oninput='MiState.invalidate_job_instance()' style='width:300px;font-size:13px;' id='" + id + "' value='" + arg_val_src + "'/></div>"
        }
    }

    //_______replace args_________
    static replace_args_wrapper_html(call_obj){
        return "<div id='mi_replace_args_wrapper_id' style='display:inline-block'></div>"
    }

    static install_replace_args_menu_items(){
        let instruction_name = this.get_instruction_name_from_ui()
        let family_class = MiIns.instruction_name_to_family_class(instruction_name)
        let the_html = this.make_menu_item_html("Defaults",         "MakeInstruction.replace_arg_vals_with_defaults()", "Values from the insruction's defaults.")
        if(family_class == MiIns.move_all_joints_family){
            the_html += this.make_menu_item_html("HOME",            "MakeInstruction.replace_arg_vals_maj_angles(Dexter.HOME_ANGLES)",    "Straight up.")
            the_html += this.make_menu_item_html("NEUTRAL",         "MakeInstruction.replace_arg_vals_maj_angles(Dexter.NEUTRAL_ANGLES)", "Between HOME and PARKED.")
            the_html += this.make_menu_item_html("PARKED",          "MakeInstruction.replace_arg_vals_maj_angles(Dexter.PARKED_ANGLES)",  "Folded compactly.")

            the_html += this.make_menu_item_html("convert to move_to", "MakeInstruction.replace_arg_vals_maj_convert_to_mt()", "make a move_to instruction\nwith args that cause Dexter\nto move to the same position\nthat this move_all_joints specifies.")
            the_html += this.make_menu_item_html("get from Dexter", "MakeInstruction.replace_arg_vals_maj_get_from_dexter()", "Joint angles from Dexter's current position.")
        }
        else if(family_class == MiIns.move_to_family){
            the_html += this.make_menu_item_html("HOME",            "MakeInstruction.replace_arg_vals_mt_angles(Dexter.HOME_ANGLES)",    "Straight up.")
            the_html += this.make_menu_item_html("NEUTRAL",         "MakeInstruction.replace_arg_vals_mt_angles(Dexter.NEUTRAL_ANGLES)", "Between HOME and PARKED.")
            the_html += this.make_menu_item_html("PARKED",          "MakeInstruction.replace_arg_vals_mt_angles(Dexter.PARKED_ANGLES)",  "Folded compactly.")

            the_html += this.make_menu_item_html("convert to move_all_joints", "MakeInstruction.replace_arg_vals_mt_convert_to_maj()", "make a move_all_joints instruction\nwith args that cause Dexter\nto move to the same position\nthat this move_to specifies.")
            the_html += this.make_menu_item_html("get from Dexter", "MakeInstruction.replace_arg_vals_mt_get_from_dexter()")
        }
        //replace_args_menu_items_id.innerHTML = the_html //fails
        let html_wrapper =  "<div id='mi_replace_args_id' " +
                                 "class='dde_menu' " +
                                 "style='display:inline-block;height:10px;padding:0px;margin-top:5px;'>" +
                                 "<ul style='display:inline-block;padding:0;margin-top:0px;'>" +
                                                        "<li id='mi_replace_args_label_id'>Replace Arg Values With ...&#9660;" +
                                                            "<ul id='replace_args_menu_items_id'>" +
                                                            the_html +
                            "</ul></li></ul></div>"
        mi_replace_args_wrapper_id.innerHTML = html_wrapper

        setTimeout(function(){
                    $("#mi_replace_args_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' })
                    $("#mi_replace_args_id").jqxMenu('setItemOpenDirection', 'mi_replace_args_label_id', 'right', 'up')
                   },
                   200)
    }

    //if action_string has inner quotes, they must be single quotes
    static make_menu_item_html(label_string, action_string, tooltip=""){
        return `<li title="` + tooltip + `" onclick="` + action_string + `">` + label_string + "</li>"
    }

    //______All the replace menu items that go on all families_______
    //the action for the "Defaults" menu item.
    static replace_arg_vals_with_defaults(){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_from_instruction_def()
        this.update_instruction_args(call_obj)
    }

    //______All the replace menu items that go on move_all_joints_family_______
    static replace_arg_vals_maj_angles(angles){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(instruction_name, angles)
        MakeInstruction.update_instruction_args(call_obj)
    }
    static replace_arg_vals_maj_get_from_dexter(){
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        new Job({name: "get_from_dexter",
                 robot: job_wrapper_robot,
                 when_stopped: function(){
                                 let instruction_name = MakeInstruction.get_instruction_name_from_ui()
                                 let angles = new RobotStatus({robot_status: last(this.rs_history)}).measured_angles(7)
                                 let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(instruction_name, angles)
                                 MakeInstruction.update_instruction_args(call_obj)
                 }
        }).start()
    }
    static replace_arg_vals_maj_convert_to_mt(){
        let new_instruction_name = "Dexter.move_to"
        let old_call_obj = this.make_call_obj_from_ui()
        let angles = old_call_obj.get_angle_array()
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(new_instruction_name, angles, job_wrapper_robot)
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    //______All the replace menu items that go on move_to_family_______
    static replace_arg_vals_mt_angles(angles){
        let instruction_name = this.get_instruction_name_from_ui()
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(instruction_name, angles, job_wrapper_robot)
       /* let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name)
        let [xyz, J5_direction, config] =
            Kin.J_angles_to_xyz(angles, job_wrapper_robot.pose)
        call_obj.args_obj.xyz            = to_source_code({value: xyz})
        call_obj.args_obj.J5_direction   = to_source_code({value: J5_direction})
        call_obj.args_obj.config         = to_source_code({value: config})
        call_obj.args_obj.workspace_pose = to_source_code({value: job_wrapper_robot.pose})
        call_obj.args_obj.j6_angle       = to_source_code({value: angles[6 - 1]})
        call_obj.args_obj.j7_angle       = to_source_code({value: angles[7 - 1]})
        */
        MakeInstruction.update_instruction_args(call_obj)
    }
    static replace_arg_vals_mt_get_from_dexter(){
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        new Job({name: "get_from_dexter",
            robot: job_wrapper_robot,
            when_stopped: function(){
                let instruction_name = MakeInstruction.get_instruction_name_from_ui()
                let angles = new RobotStatus({robot_status: last(this.rs_history)}).measured_angles(7)
                let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(instruction_name, angles, job_wrapper_robot)
                MakeInstruction.update_instruction_args(call_obj)
            }
        }).start()
    }

    static replace_arg_vals_mt_convert_to_maj(){
        let new_instruction_name = "Dexter.move_all_joints"
        let old_call_obj = this.make_call_obj_from_ui().merge_in_from_instruction_def_only_if_empty() //a move_to family
        if(old_call_obj.args_obj.j6_angle == "[0]") { old_call_obj.args_obj.j6_angle = "" } //both mean the same thing bug empty looks simpler in the dialog.
        if(old_call_obj.args_obj.j7_angle == "[0]") { old_call_obj.args_obj.j7_angle = "" }

        let xyz_src = old_call_obj.args_obj.xyz
        if(!xyz_src) {
            xyz_src = "[" + old_call_obj.args_obj.x + ", " +
                            old_call_obj.args_obj.y + ", " +
                            old_call_obj.args_obj.z +
                      "]"
        }
        let xyz
        try{ xyz = window.eval(xyz_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling xyz source of: " +
                     xyz_src + " errored with: " + err.message) }
        if(!Array.isArray(xyz)) {
            dde_error("While converting move_to to move_all_joints, evaling xyz source of: " +
                       xyz_src + " returned a non-array of: " + xyz)
        }

        let j5_direction_src = old_call_obj.args_obj.J5_direction
        let j5_direction
        try{ j5_direction = window.eval(j5_direction_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling J5_direction source of: " +
                                j5_direction_src + " errored with: " + err.message) }
        if(!Array.isArray(j5_direction)) {
            dde_error("While converting move_to to move_all_joints, evaling J5_direction source of: " +
                      j5_direction_src + " returned a non-array of: " + j5_direction)
        }

        let config_src = old_call_obj.args_obj.config
        let config
        try{ config = window.eval(config_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling config source of: " +
                                config_src + " errored with: " + err.message) }
        if(!Array.isArray(config)) {
            dde_error("While converting move_to to move_all_joints, evaling config_src source of: " +
                config_src + " returned a non-array of: " + config)
        }

        let angles = Kin.xyz_to_J_angles(xyz, j5_direction, config)

        let j6_angle_src = old_call_obj.args_obj.j6_angle
        let j6_angle
        if(j6_angle_src != "") { try{ j6_angle = window.eval(j6_angle_src)}
                            catch(err) { dde_error("While converting move_to to move_all_joints, evaling j6_angle source of: " +
                                j6_angle_src + " errored with: " + err.message) }
                         }
         else j6_angle = undefined
        angles.push(j6_angle)

        let j7_angle_src = old_call_obj.args_obj.j7_angle
        let j7_angle
        if(j7_angle_src != "") { try{ j7_angle = window.eval(j7_angle_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling j7_angle source of: " +
                                j7_angle_src + " errored with: " + err.message) }
        }
        else j7_angle = undefined
        angles.push(j7_angle)

        angles.push(old_call_obj.args_obj.j6_angle)
        let job_wrapper_robot = value_of_path(mi_job_wrapper_robot_name_id.value)
        let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(new_instruction_name, angles, job_wrapper_robot)
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    static bottom_buttons_html(){
        return  "<div style='white-space:nowrap;' ><button style='margin:3px;' onclick='MakeInstruction.eval_instruction()' " +
            "title='Eval the instruction.&#013;This is a good (but incomplete) test&#013;of the validity of the arguments.'>Eval Instr</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.run()' id='mi_run_id'" +
            "title='Make a job with the instruction in it&#013;and start the job.'>Run</button>" +

            //"<button style='margin:3px;' onclick='MakeInstruction.insert_job()' " +
            //"title='Into the Editor,&#013;insert the definition of a job&#013;with the instruction in it.'>Insert Job</button>" +
            "<button style='margin:3px;' onclick='MakeInstruction.wrap_in_job()' " +
            "title='Change the instruction to new Job&#013;and stick the current instruction&#013;into the new Job&apos;s do_list.'>Wrap in Job</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.insert_instruction()' " +
            "title='If there is a selection in the Editor,&#013;replace it,&#013;otherwise just insert the instruction.'>Insert</button>" +
            "</div>"
    }

    static make_call_obj_from_ui(){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name)
        /*let param_names = this.param_names_from_ui(instruction_name)
        for(let param_name of param_names){ //fails when we call this method from after instructio_name\
            //is channged in the UI, but before the args are set as we need to when grabbing prev values
            let id = this.arg_name_to_dom_elt_id(param_name)
            let elt = window[id]
            let arg_val_src = elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            call_obj.args_obj[param_name] = arg_val_src
        }
        */
        for(let elt of mi_args_id.getElementsByClassName('mi_arg_val_src')){
            let arg_name = this.dom_elt_id_to_arg_name(elt.id)
            let arg_val_src = elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            call_obj.args_obj[arg_name] = arg_val_src
        }
        return call_obj
    }

    //obsolete feb 21, 2019
    static param_names_from_ui(instruction_name){
        if(this.dialog_contains_move_all_joints_with_joints()){
            return ["joint1", "joint2", "joint3","joint4","joint5","joint6","joint7"]
        }
        let arg_name_val_src_pairs = function_param_names_and_defaults_array(instruction_name, true)
        let param_names = []
        for(let pair of arg_name_val_src_pairs) { param_names.push(pair[0]) }
        let mt_separate_xyzs = this.dialog_contains_move_to_with_separate_xyzs()
        if (mt_separate_xyzs){
            if(param_names[0] == "xyz") { param_names.shift() }
            else { shouldnt("no first 'xyz' param in dialog_to_instruction_src with instruction: " + instruction_name +
                " and param_names: " + param_names) }
            param_names.unshift("z")
            param_names.unshift("y")
            param_names.unshift("x")

        }
        if(starts_with_one_of(instruction_name, ["Dexter.", "Serial."]) && (last(param_names) == "robot")) {
            param_names.pop() //user should be using robot instance as subject, not as last arg
            //else { shouldnt("no last 'robot' param_name in dialog_to_instruction_src with instruction: " + instruction_name +
            //                " and param_names: " + param_names)  }
        }
        return param_names
    }

    //if eval_args is true, test the instruction name and arg src.
    //by evaling it. If it errors, print a good error message,
    //highlight the approirate field in the dialog,
    //and return null, otherwise return a string of valid src for the instruction.
    static dialog_to_instruction_src(eval_args=false){
        if(!this.validate_instruction_name_ui()) { return false } //error messages are printed by this
        let call_obj = this.make_call_obj_from_ui()
        return this.call_obj_to_instruction_src(eval_args, call_obj)
    }
    //called by insert job code as well
    static call_obj_to_instruction_src(eval_args=false, call_obj){
        let family_class = call_obj.get_family_class()
        if(family_class == MiIns.function_family) {
          return this.call_obj_to_instruction_src_for_function(eval_args, call_obj)
        }
        else if(family_class == MiIns.array_family){
            return this.call_obj_to_instruction_src_for_array(eval_args, call_obj)
        }
        else { return this.call_obj_to_instruction_src_for_normal(eval_args, call_obj) }
    }

    static call_obj_to_instruction_src_for_normal(eval_args=false, call_obj){
        let family_of_instruction = call_obj.get_family_class()
        let instruction_name = call_obj.get_instruction_name()
        let result = instruction_name + "("
        let maj_with_joints  = this.dialog_contains_move_all_joints_with_joints()
        if(maj_with_joints) { result += "[" }
        let fn = call_obj.get_instruction_class()
        let fn_is_keyword = fn_is_keyword_fn(fn)
        if(fn_is_keyword) { result += "{\n" }
        let arg_name_val_src_pairs = function_param_names_and_defaults_array(instruction_name, true)
        let param_names = Object.getOwnPropertyNames(call_obj.args_obj)
        let src_before_undefined = result
        for(let param_name of param_names){
            let arg_default_val_src = this.find_arg_val_src_in_arg_name_val_src_pairs(param_name, arg_name_val_src_pairs)
            if((family_of_instruction == MiIns.move_all_joints_family) &&
               param_name.startsWith("joint") &&
               (arg_default_val_src == undefined)) {
                arg_default_val_src = ""
            }
            //let id = this.arg_name_to_dom_elt_id(param_name)
            //let elt = window[id]
            let arg_val_src = call_obj.args_obj[param_name] //elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            if(eval_args){
                if(!this.validate_arg_ui(instruction_name, param_name, arg_val_src)) { return null }
            }
            let arg_val_is_default = false
            if (arg_val_src === "") { //typein is empty so use the default val
                arg_val_src = arg_default_val_src
                arg_val_is_default = true
            }
            else if(arg_val_src == arg_default_val_src) { arg_val_is_default = true }
            else if(arg_val_src == "undefined")         { arg_val_is_default = true }

            let did_insert_arg   = true
            let mt_separate_xyzs = this.dialog_contains_move_to_with_separate_xyzs()
            if (mt_separate_xyzs && (param_name == "x")) {
                if(fn_is_keyword)                            { result += "xyz: [" + arg_val_src }
                else                                         { result += "[" + arg_val_src }
            }
            else if(mt_separate_xyzs && (param_name == "y")) { result += arg_val_src }
            else if(mt_separate_xyzs && (param_name == "z")) { result += arg_val_src + "]"}
            else if(fn_is_keyword){
                    if(!arg_val_is_default || mi_insert_default_args_id.checked)  {
                       if(param_name == "do_list"){
                           arg_val_src = "\n        " + arg_val_src.trim() //8 spaces (2 tabs)
                       }
                                                                    result += "    " + param_name + ": " + arg_val_src
                    }
                    else { did_insert_arg = false }                                         //insert nothing
            }
            else  {                                                 result += arg_val_src }
            if (!(last(param_names) == param_name) && did_insert_arg) {
                if(fn_is_keyword) { result += ",\n" }
                else              { result += ", " }
            }
            if(!arg_val_is_default || mi_insert_default_args_id.checked) {
                src_before_undefined = result   //don't include in src trailing undefineds
            }
        }
        //get rid of extra whitespace and comma at the end, otherwise option-click fails on parsing, even though now js ok with extra comma.
        src_before_undefined = trim_end(src_before_undefined)
        if(src_before_undefined.endsWith(",")) {
            src_before_undefined = src_before_undefined.substring(0, src_before_undefined.length - 1)
        }
        if(maj_with_joints) {
            src_before_undefined += "]"
        }
        if(fn_is_keyword) { src_before_undefined += "}" }
        result = src_before_undefined + ")"
        return result
    }

    static validate_arg_ui(instruction_name, param_name, arg_val_src){
        if ((instruction_name == "new Job") && (param_name == "do_list")){
            let ast
            try{ ast = MiParser.string_to_ast(arg_val_src)}
            catch(err){
                this.set_border_color_of_arg(param_name, "red")
                let short_arg_val_src = ((arg_val_src.length > 60) ? arg_val_src.substring(0, 60) + "..." : arg_val_src)
                out("<span style='color:red'>Error: </span>" +
                    "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                    "with source of: " +
                    "<code style='padding:3px;'>" + short_arg_val_src + "</code><br/>" +
                    "errored because <span style='color:red;'>" + err.message +
                    "</span><br/>Correct errors and try again.")
                return false
            }
            let body0_expression_ast = ast.body[0].expression
            if(body0_expression_ast.type == "ArrayExpression"){
                let elts_array = body0_expression_ast.elements
                for(let i = 0; i < elts_array.length; i++){
                    let elt_ast = elts_array[i]
                    let elt_src = arg_val_src.substring(elt_ast.range[0], elt_ast.range[1])
                    try{
                        let do_list_item = window.eval(elt_src)
                        if(!Instruction.is_do_list_item(do_list_item)){
                            this.set_border_color_of_arg(param_name, "red")
                            out("<span style='color:red'>Error: </span>" +
                                "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                                "element " + i + " (zero based) of " + elts_array.length + " with source of:<br/>" +
                                "<code style='padding:3px;'>" + elt_src + "</code><br/>" +
                                "errored because it evaled to: " + do_list_item + "<br/>" +
                                "and <span style='color:red;'> that is not a valid do_list item." +
                                "</span><br/>Correct errors and try again.")
                            open_doc(do_list_doc_id)
                            return false
                        }
                    }
                    catch(err){
                        this.set_border_color_of_arg(param_name, "red")
                        out("<span style='color:red'>Error: </span>" +
                            "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                            "element " + i + " (zero based) of " + elts_array.length + " with source of:<br/>" +
                            "<code style='padding:3px;'>" + elt_src + "</code><br/>" +
                            "errored because:" + "<span style='color:red;'> " + err.message +
                            "</span><br/>Correct errors and try again.")
                        return false
                    }
                }
            }
        }
        else {
            try{
                window.eval(arg_val_src)
                this.set_border_color_of_arg(param_name)
            }
            catch(err){
                this.set_border_color_of_arg(param_name, "red")
                out("<span style='color:red'>Error: </span>" +
                    "In <i>Make Instruction</i>, evaling the <b>" + param_name + "</b> source of:<br/>" +
                    "<code style='padding:3px;'>" + arg_val_src + "</code><br/>errored because:" +
                    "<span style='color:red;'> " + err.message +
                    "</span><br/>Correct errors and try again.")
                return false
            }
        }
        return true //everything ok
    }

    //instruction_name is either "function" or "function*"
    //note that this method ignores eval_args because
    //none of the "args" are really evalable.
    static call_obj_to_instruction_src_for_function(eval_args=false){
        let instruction_name = this.get_instruction_name_from_ui()
        let id
        let elt
        id = this.arg_name_to_dom_elt_id("name")
        elt = window[id]
        let the_name_src = elt.value.trim()
        id = this.arg_name_to_dom_elt_id("...params")
        elt = window[id]
        let the_params_src = elt.value.trim()
        id = this.arg_name_to_dom_elt_id("body")
        elt = window[id]
        let the_body_src  = elt.value.trim()
        the_body_src = "\n" + the_body_src
        the_body_src = replace_substrings(the_body_src, "\n", "\n    ")

        let result = ((the_name_src == "") ? instruction_name: instruction_name + " " + the_name_src )
        result += "(" + the_params_src + "){" + the_body_src + "\n}\n"
        return result
    }

    static call_obj_to_instruction_src_for_array(eval_args=false){
        let param_name = "...elts"
        let id = this.arg_name_to_dom_elt_id(param_name)
        let elt = window[id]
        let args_val_src = elt.value.trim()
        if(eval_args){
            let arg_val_src_array = args_val_src.split(",")
            for(let i = 0; i < arg_val_src_array.length; i++){
                let arg_val_src = arg_val_src_array[i]
                try{
                    window.eval(arg_val_src)
                    this.set_border_color_of_arg(param_name)
                }
                catch(err){
                    this.set_border_color_of_arg(param_name, "red")
                    out("<span style='color:red'>Error: </span>" +
                        "In <i>Make Instruction</i>, evaling the <b>" + param_name + "</b> source at index " + i + " of<br/>" +
                        "<code style='padding:3px;'>" + arg_val_src + "</code><br/>errored because:" +
                        "<span style='color:red;'> " + err.message +
                        "</span><br/>Correct errors and try again.")
                    return null
                }
            }
        }
        return "[" + args_val_src + "]"
    }

    static eval_instruction(){
        let src = this.dialog_to_instruction_src(true)
        if(src !== null) {
            src = this.fix_src_of_function_maybe(src)
            eval_js_part2(src)
        }
    }

    static fix_src_of_function_maybe(src) {
        let instruction_name = this.get_instruction_name_from_ui()
        if (MiIns.instruction_name_in_family_class(instruction_name, MiIns.function_family)) {
            src = "(" + src + ")" //due to js design mistake,
                                  //anonymous fn defs can't be evaled without
                                  //wrapping them in parens.
                                  //we might have a NAMED fn here, but the parens
                                  //are harmless for that.
        }
        return src
    }

    static run(){
        let call_obj = this.make_call_obj_from_ui() //don't reshow the inst_src because that goes through the pipelinne
           //which merges in prev values, etc. which we don't want.
        let inst_src = this.dialog_to_instruction_src()
        if(!this.src_looks_like_valid_instruction(inst_src)){
            if(starts_with_one_of(inst_src, "new Dexter(", "new Serial(")){
                warning("You've created a Robot in the Make Instruction dialog.<br/>" +
                    "A Robot isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            else {warning("The code you've created in the Make Instruction dialog<br/>" +
                    "isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            return
        }
        inst_src = this.fix_src_of_function_maybe(inst_src)
        let the_inst = eval(inst_src)
        let job_wrapper_robot_name = mi_job_wrapper_robot_name_id.value
        if(the_inst instanceof Job){
            if(Robot.simulate_or_both_selected()){
                misc_pane_menu_changed("Simulate Dexter")
                //to give user time to adjust to the sim pane
                let when_stopped_fn = function(){
                    setTimeout(function() { MakeInstruction.show(call_obj, job_wrapper_robot_name, false) },
                        2000)
                }
                setTimeout(function() { the_inst.start({when_stopped: when_stopped_fn}) }, //doesn't work to just set when_stopped on the instance because that won't make it into the orig_args storage
                    2000)
            }
            else {  the_inst.start() }
        }
        else {
            let robot_of_wrapper = value_of_path(mi_job_wrapper_robot_name_id.value)
            let job_00
            if((this.get_instruction_name_from_ui() == "new Job") &&
                robot_of_wrapper == the_inst.robot) {
                warning("When using a Job as an instruction (to start it),<br/>" +
                        "its robot must be different than the Job its in.<br/>" +
                        "They are the same in this case so this use of the Run button<br/>" +
                        "didn't wrap the new Job instruction you specified in another Job before running it.")
                job_00 = the_inst
            }
            else {
                job_00 = new Job({name: "job_00",
                                  robot: value_of_path(job_wrapper_robot_name),
                                  do_list: [the_inst],
                                  when_stopped: function(){
                                                   setTimeout(function() { MakeInstruction.show(call_obj, job_wrapper_robot_name, false) },
                                                              2000)
                                                }
                         })
            }
            let true_or_error_mess = Instruction.can_instruction_run_on_robot(the_inst, robot_of_wrapper)
            if(typeof(true_or_error_mess) == "string") {
                dde_error(true_or_error_mess)
            }
            else if(Robot.simulate_or_both_selected()){
                misc_pane_menu_changed("Simulate Dexter")
                //to give user time to adjust to the sim pane
                setTimeout(function() { job_00.start() },
                           2000)
            }
            else {  job_00.start() } //don't switch to simulator if we're not simulating
        }
    }

    static wrap_in_job(){
        let old_call_object = this.make_call_obj_from_ui()
        let old_instruction_name = old_call_object.get_instruction_name()
        let old_instr_src
        if(old_instruction_name == "new Job"){
            let old_job_name = old_call_object.args_obj.name.trim()
            if (['""', "''", ""].includes(old_call_object.args_obj.name.trim())){
                dde_error("When inserting a Job as a do_list item in another Job,<br/>" +
                    "that inner job needs a name but this one doesn't have one.<br/>" +
                    "Also, the inner job should be inserted into a file<br/>" +
                    "so you can define it before this new Job is started.<br/>"
                    )
            }
            else {
                warning("For this new Job to work, the embedded job<br/>" +
                        "must be saved and defined before running this new Job.")
                old_instr_src = 'Robot.include_job(' + old_job_name + ')'
            }
        }
        else { //a non "new job" old instruction
            old_instr_src = this.dialog_to_instruction_src(true)
            if (!old_instr_src) { return false } //some error in the instruction code so don't continue.
        }
        let call_obj = MiIns.make_from_instruction_name_no_args("new Job").
                       merge_in_pipeline()
        call_obj.args_obj.do_list = "[" + old_instr_src + "]"
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    static insert_instruction(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(instruction_name == "new Job") {
            this.show_insert_job_dialog()
        }
        else {
            let src = this.dialog_to_instruction_src()
            let suffix = ""
            if(Editor.is_selection()) { Editor.replace_selection(src)} //trailing comma ok inside of an array
            else {
                let suffix
                if(this.src_looks_like_valid_instruction(src)){ //these are not valid instructions, so can't be in a do_list, so shouldn't be followed by a comma
                    suffix = ",\n    "
                }
                else { suffix = "\n"}
                Editor.insert(src + suffix)
            }
        }
    }
    static show_insert_job_dialog(){
        let job_name = window[this.arg_name_to_dom_elt_id("name")].value
        if (job_name == '""') { job_name = "recording" }
        else { job_name = job_name.substring(1, job_name.length - 1) }
        show_window({title: "Insert Job(s)",
            y: 180,
            width:  340,
            height: 340,
            background_color: "#E0E0E0",
            content:
            "<fieldset><legend>Insert Job reference at editor cursor</legend>" +
                "<i>Insertion goes after selection,<br/>not in place of it.</i><br/>" +
                "<input id='mi_job_insert_ref_none_radio_id' type='radio' name='mi_job_ref_radio' checked/> None<br/>" +
                "<input id='mi_job_insert_ref_refs_radio_id' type='radio' name='mi_job_ref_radio'        /> Reference only<br/>" +
                "<input id='mi_job_insert_ref_job_radio_id'  type='radio' name='mi_job_ref_radio'        /> Job containing reference<br/>" +
                "<i style='margin-left:30px'>Job name</i>: <input id='mi_job_insert_ref_job_name_id'     style='width:175px;' value='" + job_name + "_refs'    /><br/>" +
            "</fieldset><br/>" +

            "<fieldset><legend>Insert Job instructions at end of editor</legend>" +
                "<input id='mi_job_insert_seg_jobs_checkbox_id' type='checkbox' checked/> " +
                "<i style='margin-left:3px'>Job name</i>: <input id='mi_job_insert_def_job_name_id' style='width:175px;' value='" + job_name + "'/><br/>" +
            "</fieldset><br/>" +

            "<center><button onclick='MakeInstruction.insert_jobs_preview()' title='Show the code to be inserted\nwhen you click Insert.'>Preview...</button> &nbsp;" +
                    "<button onclick='MakeInstruction.insert_jobs()' title='Insert selected code into editor.'>Insert</button>" +
            "</center>"
        })
    }
    static insert_jobs_preview(){
        let seg_refs_code = this.segment_reference_code()
        if (seg_refs_code == "") { seg_refs_code = "<i style='color:red;'>nothing to insert</i>" }

        let seg_jobs_code = this.segment_job_code()
        if (seg_jobs_code == "") { seg_jobs_code = "<i style='color:red;'>nothing to insert</i>" }

        let content = "<div style='font-size:16px;'><b>Job Reference</b></div>" +
            "<i>To be inserted at the editor's cursor.</i><br/><pre><code>" +
            seg_refs_code +
            "</code></pre><p/>" +
            "<div style='font-size:16px;'><b>Job Definition</b></div>" +
            "<i>To be inserted at the end of the editor.</i><br/><pre><code>" +
            seg_jobs_code +
            "</code></pre>"
        show_window({title: "Insert Jobs Preview",
            content: content,
            x:10, y:40, width:600, height:500,
            background_color: "#E0E0E0"
        })
    }
    static insert_jobs(){
        let seg_ref_code = this.segment_reference_code()
        if (seg_ref_code != "") { Editor.insert(seg_ref_code, "selection_end") }
        let seg_job_code = this.segment_job_code()
        if (seg_job_code != "") { Editor.insert(seg_job_code, "end") }
        if((seg_ref_code == "") && (seg_job_code == "")) {
            warning("No code chosen for insertion.")
        }
    }

    static segment_reference_code(){
        //let selected_radio_button = document.querySelector('input[name="mi_job_ref_radio"]:checked').id
        let result = ""
        if(mi_job_insert_ref_none_radio_id.checked) { return "" }

        else if(mi_job_insert_ref_refs_radio_id.checked) {
            return 'Robot.include_job("' + mi_job_insert_def_job_name_id.value  + '")'
        }
        if(mi_job_insert_ref_job_radio_id.checked) {
            return '\n//A high-level Job that includes other jobs.\n' +
                   'new Job({name: "' + mi_job_insert_ref_job_name_id.value + '",\n' +
                   '         do_list: [\n' +
                   '                   Robot.include_job("' + mi_job_insert_def_job_name_id.value  + '")\n' +
                   '                  ]})\n'
        }
        return result
    }

    //return "" if no instructions selected, else return src code for a job with the proper do_list
    static segment_job_code(){
       if(!mi_job_insert_seg_jobs_checkbox_id.checked) { return "" }
       else {
        let target_job_name = mi_job_insert_def_job_name_id.value
        let src_job_name = window.eval(MakeInstruction.arg_name_to_src_in_mi_dialog("name")) //might not just be a literal, could be an expression!
        let job_instance = Job[src_job_name]
        //the below IF-ELSE  computes do_list_to_use. After that, make its src code.
        let do_list_to_use = []
        if(!job_instance || (job_instance != MiState.job_instance) || !MiState.job_instance.do_list){ //not in sync so prefer the def in the dialog
            do_list_to_use = window.eval(MakeInstruction.arg_name_to_src_in_mi_dialog("do_list"))
        }
        else {
            let [begin1, end1, begin2, end2] = MiRecord.get_play_instruction_locs()
            if(begin1 === undefined) { return "" } //no instructions.
            else if(mi_play_middle_checkbox_id.checked){
                let begin_id_into_do_list = job_instance.find_top_level_instruction_id_for_id(begin1)
                let end_id_into_do_list   = job_instance.find_top_level_instruction_id_for_id(end1)
                for(let i = begin_id_into_do_list; i <= end_id_into_do_list; i++){
                    if(job_instance.is_top_level_do_list_item(i)) {
                        do_list_to_use.push(job_instance.do_list[i])
                    }
                }
            }
            else { //concatenate the ends together, leaving out the middle
                let begin_id_into_do_list = job_instance.find_top_level_instruction_id_for_id(end1) //end1 is *included* in this first seg
                //grab the first, head seg.
                for(let i = 0; i <= begin_id_into_do_list; i++){
                    if(job_instance.is_top_level_do_list_item(i)) {
                        do_list_to_use.push(job_instance.do_list[i])
                    }
                }
                if(begin2 === undefined) {} //no "tail" to include
                else { //grab the tail seg
                    let first_id_of_end_segment
                    //begin2 is in the tail (its not the end marker pos, its one higher.
                    //if begin2 is  top level item, great, use it.
                    //else back up in the do_list and find its top level item, and use that,
                    //even though that will be in the "middle" seg.
                    first_id_of_end_segment = job_instance.find_top_level_instruction_id_for_id(begin2)
                    for(let i = first_id_of_end_segment; i < job_instance.do_list.length; i++){
                        if(job_instance.is_top_level_do_list_item(i)) {
                            do_list_to_use.push(job_instance.do_list[i])
                        }
                    }
                }
            }
        }
        let do_list_src = to_source_code({value: do_list_to_use, one_line_per_array_elt:true})
        do_list_src = replace_substrings(do_list_src, "\n", "\n                   ") //indent 2nd thru nth lines
        do_list_src = do_list_src.trim() //get rid of extra whitespace at end
        return 'new Job({name: "' + target_job_name + '",\n' +
               '         do_list: ' + do_list_src + "\n" +
               '        })\n'
       }
    }

    /*
    static show_insert_job_dialog(){
       let job_name = window[this.arg_name_to_dom_elt_id("name")].value
       if (job_name == '""') { job_name = "recording" }
       else { job_name = job_name.substring(1, job_name.length - 1) }
       show_window({title: "Insert Job(s)",
                    y: 180, height: 470,
                    background_color: "#E0E0E0",
                    content:
        "<fieldset><legend>Segments to include</legend>" +
        "<input id='mi_job_insert_begin_checkbox_id'  type='checkbox' " + (mi_play_seg_begin_id.checked  ? "checked" : "") + " />begin" +
        "<i style='margin-left:30px'>name</i>: <input id='mi_job_insert_begin_name_id'  value='" + job_name + "_begin' /><br/>" +
        "<input id='mi_job_insert_middle_checkbox_id' type='checkbox' " + (mi_play_seg_middle_id.checked ? "checked" : "") + " />middle" +
        "<i style='margin-left:20px'>name</i>: <input id='mi_job_insert_middle_name_id' value='" + job_name + "_middle'/><br/>" +
        "<input id='mi_job_insert_end_checkbox_id'    type='checkbox' " + (mi_play_seg_end_id.checked    ? "checked" : "") + " />end" +
        "<i style='margin-left:43px'>name</i>: <input id='mi_job_insert_end_name_id'    value='" + job_name + "_end'    /><br/>" +
        "</fieldset>" +
        "<fieldset><legend>Insert Selected Segment References</legend>" +
        "<input id='mi_job_insert_ref_none_radio_id' type='radio' name='mi_job_ref_radio' checked/> None<br/>" +
        "<input id='mi_job_insert_ref_refs_radio_id' type='radio' name='mi_job_ref_radio'        /> References only<br/>" +
        "<input id='mi_job_insert_ref_job_radio_id'  type='radio' name='mi_job_ref_radio'        /> Job containing references<br/>" +
        "<i style='margin-left:95px'>name</i>: <input id='mi_job_insert_ref_job_name_id' value='" + job_name + "_refs'/><br/>" +

        "<i>References will be inserted at editor cursor.</i>" +
        "</fieldset>" +
        "<fieldset style='margin-bottom:5px;'><legend>Insert Selected Segment Jobs</legend>" +
        "<input id='mi_job_insert_seg_jobs_none_radio_id'    type='radio' name='mi_job_insert_seg_radio'        /> None<br/>" +
        "<input id='mi_job_insert_seg_jobs_one_per_radio_id' type='radio' name='mi_job_insert_seg_radio'        /> One Job per selected segment<br/>" +
        "<input id='mi_job_insert_seg_jobs_one_all_radio_id' type='radio' name='mi_job_insert_seg_radio' checked/> One Job of all selected segments<br/>" +
        "<i style='margin-left:95px'>name</i>: <input id='mi_job_insert_seg_jobs_name_id' value='" + job_name + "'/><br/>" +
        "<input id='mi_job_insert_seg_jobs_checkbox_id' type='checkbox'/>Include excluded tails<br/>" +
        "<i>These Jobs inserted at end of editor.</i>" +
        "</fieldset>" +
        "<center><button onclick='MakeInstruction.insert_jobs_preview()'>Preview</button> &nbsp;" +
        "<button>Insert</button></center>"
       })
    }
    static insert_jobs_preview(){
        let seg_refs_code = this.segment_references_code()
        if (seg_refs_code == "") { seg_refs_code = "<i style='color:red;'>nothing to insert</i>" }

        let seg_jobs_code = this.segment_jobs_code()
        if (seg_jobs_code == "") { seg_jobs_code = "<i style='color:red;'>nothing to insert</i>" }

        let content = "<div style='font-size:16px;'><b>Selected Segment References</b></div>" +
                    "<i>To be inserted at the editor's cursor.</i><br/><pre><code>" +
                     seg_refs_code +
                    "</code></pre><p/><div style='font-size:16px;'><b>Selected Segment Jobs</b></div>" +
                    "<i>To be inserted at the end of the editor.</i><br/><pre><code>" +
                    seg_jobs_code +
                    "</code></pre>"
        show_window({title: "Insert Jobs Preview",
                    content: content,
                    x:10, y:40, width:600, height:500
        })
    }

    static segment_references_code(){
        let selected_id = document.querySelector('input[name="mi_job_ref_radio"]:checked').id
        let result = ""
        if     (selected_id == "mi_job_insert_ref_none_radio_id") { result = "" }
        else if(selected_id == "mi_job_insert_ref_refs_radio_id") {
            result += this.segment_references_code_refs()
        }
        else if(selected_id == "mi_job_insert_ref_job_radio_id") {
            let call_obj = MakeInstruction.make_call_obj_from_ui()
            let refs     = "[" + this.segment_references_code_refs().trim() + "]"
            call_obj.args_obj.do_list = refs
            result = MakeInstruction.call_obj_to_instruction_src(true, call_obj)
        }
        else { shouldnt("in MakeInstruction.segment_references_code") }
        return result
    }

    static segment_references_code_refs(){
        let result = ""
        if(mi_job_insert_begin_checkbox_id.checked) {
            result += '        Robot.include_job("' + mi_job_insert_begin_name_id.value  + '")'
        }
        if(mi_job_insert_middle_checkbox_id.checked) {
            if(result != "") { result += ",\n" }
            result += '        Robot.include_job("' + mi_job_insert_middle_name_id.value  + '")'
        }
        if(mi_job_insert_end_checkbox_id.checked) {
            if(result != "") { result += ",\n" }
            result += '        Robot.include_job("' + mi_job_insert_end_name_id.value  + '")'
        }
        return result
    }

    static segment_jobs_code(){
       let selected_id = document.querySelector('input[name="mi_job_insert_seg_radio"]:checked').id
       let result = ""
       if(selected_id == "mi_job_insert_seg_jobs_none_radio_id") { result = "" }
       else if(selected_id == 'mi_job_insert_seg_jobs_one_per_radio_id') {
           if(mi_job_insert_begin_checkbox_id.checked) {
               let call_obj = MakeInstruction.make_call_obj_from_ui()
               call_obj.args_obj.name = '"' + mi_job_insert_begin_name_id.value + '"'
               let new_src = MakeInstruction.call_obj_to_instruction_src(true, call_obj)
               result += new_src + "\n"
           }
           if(mi_job_insert_middle_checkbox_id.checked) {
               let call_obj = MakeInstruction.make_call_obj_from_ui()
               call_obj.args_obj.name = '"' + mi_job_insert_middle_name_id.value + '"'
               let new_src = MakeInstruction.call_obj_to_instruction_src(true, call_obj)
               result += new_src + "\n"
           }
           if(mi_job_insert_end_checkbox_id.checked) {
               let call_obj = MakeInstruction.make_call_obj_from_ui()
               call_obj.args_obj.name = '"' + mi_job_insert_end_name_id.value + '"'
               let new_src = MakeInstruction.call_obj_to_instruction_src(true, call_obj)
               result += new_src + "\n"
           }
       }
       else if(mi_job_insert_seg_jobs_one_all_radio_id){
           result = "mi_job_insert_seg_jobs_one_all_radio_id needs work"
       }
       else { shouldnt("in MakeInstruction.segment_jobs_code, can't handle selected id: " + selected_id) }

       return result
    }*/

} //end class



MakeInstruction.menu_hierarchy = [
    ["Dexter move",  "move_all_joints", "move_all_joints_relative",
                     "move_home",
                     "move_to", "move_to_relative", "move_to_straight",
                     "pid_move_all_joints", "pid_move_to"],
    ["Dexter mode",  "set_follow_me", "set_force_protect", "set_keep_position", "set_open_loop"],
    ["Dexter common", "draw_dxf", "empty_instruction_queue_immediately", "empty_instruction_queue",
                      "get_robot_status", "get_robot_status_immediately", "make_ins", "read_from_robot",
                      "run_gcode", "set_parameter", "write_to_robot"],
    ["Dexter rare", "capture_ad", "capture_points", "cause_error", "dma_read", "dma_write", "exit",
                    "find_home", "find_home_rep", "find_index", "load_tables",
                    "record_movement", "replay_movement",
                    "sleep",  "slow_move", "write"],
    ["Human",       "enter_choice", "enter_filepath", "enter_instruction", "enter_number",
                    "enter_position", "enter_text", "notify", "show_window", "speak", "task"],
    ["Robot control", "break", "go_to", "loop","label",
                      "suspend", "unsuspend", "sync_point", "wait_until"],
    ["Robot I/O",  "get_page", "grab_robot_status",  "out",
                   "show_picture", "show_video", "take_picture"],
    ["Robot Jobs", "send_to_job", /*"sent_from_job" don't let user use this*/
                   "start_job", "stop_job"],
    ["Robot bugs", "debugger", "error", "if_any_errors"],
    ["Serial",     "string_instruction"],
    ["Misc"      , "function", "function*",
                   //"null", don't have null on menu. its a valid instruction but does nothing, hard to support, and you wouldn't explicitly put one in a job's do_list
                    "new Array", "new Job", "new Note", "new Phrase", "new TestSuite",
                   "new Dexter", "new Serial"
                   ]
]

var esprima = require('esprima')
var {ends_with_one_of, fn_is_keyword_fn, replace_substrings, starts_with_one_of, trim_end} = require("./core/utils.js")
var {to_source_code} = require("./core/to_source_code.js")